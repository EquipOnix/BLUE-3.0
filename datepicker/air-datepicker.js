const localeCs = {
    days: ['Neděle', 'Pondělí', 'Úterý', 'Středa', 'Čtvrtek', 'Pátek', 'Sobota'],
    daysShort: ['Ne', 'Po', 'Út', 'St', 'Čt', 'Pá', 'So'],
    daysMin: ['Ne', 'Po', 'Út', 'St', 'Čt', 'Pá', 'So'],
    months: ['Leden', 'Únor', 'Březen', 'Duben', 'Květen', 'Červen', 'Červenec', 'Srpen', 'Září', 'Říjen', 'Listopad', 'Prosinec'],
    monthsShort: ['Led', 'Úno', 'Bře', 'Dub', 'Kvě', 'Čvn', 'Čvc', 'Srp', 'Zář', 'Říj', 'Lis', 'Pro'],
    today: 'Dnes',
    clear: 'Vymazat',
    dateFormat: 'dd.MM.yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeDa = {
    days: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'],
    daysShort: ['Søn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lør'],
    daysMin: ['Sø', 'Ma', 'Ti', 'On', 'To', 'Fr', 'Lø'],
    months: ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'],
    monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    today: 'I dag',
    clear: 'Nulstil',
    dateFormat: 'dd/MM/yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeDe = {
    days: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
    daysShort: ['Son', 'Mon', 'Die', 'Mit', 'Don', 'Fre', 'Sam'],
    daysMin: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
    months: ['Januar','Februar','März','April','Mai','Juni', 'Juli','August','September','Oktober','November','Dezember'],
    monthsShort: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
    today: 'Heute',
    clear: 'Aufräumen',
    dateFormat: 'dd.MM.yyyy',
    timeFormat: 'HH:ii',
    firstDay: 1
};

const localeEn = {
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    daysMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    today: 'Today',
    clear: 'Clear',
    dateFormat: 'MM/dd/yyyy',
    timeFormat: 'hh:mm aa',
    firstDay: 0
};

const localeEs = {
    days: ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'],
    daysShort: ['Dom', 'Lun', 'Mar', 'Mie', 'Jue', 'Vie', 'Sab'],
    daysMin: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sa'],
    months: ['Enero','Febrero','Marzo','Abril','Mayo','Junio', 'Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'],
    monthsShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
    today: 'Hoy',
    clear: 'Limpiar',
    dateFormat: 'dd/MM/yyyy',
    timeFormat: 'hh:mm aa',
    firstDay: 1
};

const localeFi = {
    days: ['Sunnuntai', 'Maanantai', 'Tiistai', 'Keskiviikko', 'Torstai', 'Perjantai', 'Lauantai'],
    daysShort: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
    daysMin: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
    months: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
    monthsShort: ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'],
    today: 'Tänään',
    clear: 'Tyhjennä',
    dateFormat: 'dd.MM.yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeFr = {
    days: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
    daysShort: ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'],
    daysMin: ['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa'],
    months: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
    monthsShort: ['Jan', 'Fév', 'Mars', 'Avr', 'Mai', 'Juin', 'Juil', 'Août', 'Sep', 'Oct', 'Nov', 'Dec'],
    today: "Aujourd'hui",
    clear: 'Effacer',
    dateFormat: 'dd/MM/yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeHu = {
    days: ['Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat'],
    daysShort: ['Va', 'Hé', 'Ke', 'Sze', 'Cs', 'Pé', 'Szo'],
    daysMin: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
    months: ['Január', 'Február', 'Március', 'Április', 'Május', 'Június', 'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December'],
    monthsShort: ['Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún', 'Júl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
    today: 'Ma',
    clear: 'Törlés',
    dateFormat: 'yyyy-MM-dd',
    timeFormat: 'hh:mm aa',
    firstDay: 1
}

const localeNl = {
    days: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
    daysShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
    daysMin: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
    months: ['Januari', 'Februari', 'Maart', 'April', 'Mei', 'Juni', 'Juli', 'Augustus', 'September', 'Oktober', 'November', 'December'],
    monthsShort: ['Jan', 'Feb', 'Mrt', 'Apr', 'Mei', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    today: 'Vandaag',
    clear: 'Legen',
    dateFormat: 'dd-MM-yyyy',
    timeFormat: 'HH:mm',
    firstDay: 0
};

const localePl = {
    days: ['Niedziela', 'Poniedziałek', 'Wtorek', 'Środa', 'Czwartek', 'Piątek', 'Sobota'],
    daysShort: ['Nie', 'Pon', 'Wto', 'Śro', 'Czw', 'Pią', 'Sob'],
    daysMin: ['Nd', 'Pn', 'Wt', 'Śr', 'Czw', 'Pt', 'So'],
    months: ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'],
    monthsShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru'],
    today: 'Dzisiaj',
    clear: 'Wyczyść',
    dateFormat: 'yyyy-MM-dd',
    timeFormat: 'hh:mm:aa',
    firstDay: 1
};

const localePrBr = {
    days: ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'],
    daysShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sab'],
    daysMin: ['Do', 'Se', 'Te', 'Qu', 'Qu', 'Se', 'Sa'],
    months: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
    monthsShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
    today: 'Hoje',
    clear: 'Limpar',
    dateFormat: 'dd/MM/yyyy',
    timeFormat: 'HH:mm',
    firstDay: 0
};

const localePt = {
    days: ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'],
    daysShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sab'],
    daysMin: ['Do', 'Se', 'Te', 'Qa', 'Qi', 'Sx', 'Sa'],
    months: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
    monthsShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
    today: 'Hoje',
    clear: 'Limpar',
    dateFormat: 'dd/MM/yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeRo = {
    days: ['Duminică', 'Luni', 'Marţi', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă'],
    daysShort: ['Dum', 'Lun', 'Mar', 'Mie', 'Joi', 'Vin', 'Sâm'],
    daysMin: ['D', 'L', 'Ma', 'Mi', 'J', 'V', 'S'],
    months: ['Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie', 'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'],
    monthsShort: ['Ian', 'Feb', 'Mar', 'Apr', 'Mai', 'Iun', 'Iul', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'],
    today: 'Azi',
    clear: 'Şterge',
    dateFormat: 'dd.MM.yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeRu = {
    days: ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'],
    daysShort: ['Вос', 'Пон', 'Вто', 'Сре', 'Чет', 'Пят', 'Суб'],
    daysMin: ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'],
    months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
    monthsShort: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
    today: 'Сегодня',
    clear: 'Очистить',
    dateFormat: 'dd.MM.yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeSi = {
    days: ['ඉරිදා', 'සදුදා', 'අඟහරැවදා', 'බදාදා', 'බ්‍රහස්‍පතින්‍', 'සිකුරාදා', 'සෙනසුරාදා'],
    daysShort: ['ඉරිදා', 'සදුදා', 'අඟහ', 'බදාදා', 'බ්‍රහස්‍', 'සිකුරා', 'සෙන'],
    daysMin: ['ඉරි', 'සදු', 'අඟ', 'බදා', 'බ්‍රහ', 'සිකු', 'සෙ'],
    months: ['ජනවාරි', 'පෙබරවාරි', 'මාර්තු', 'අප්‍රේල්', 'මැයි', 'ජූනි', 'ජූලි', 'අගෝස්තු', 'සැප්තැම්බර්', 'ඔක්තෝබර්', 'නොවැම්බර්', 'දෙසැම්බර්'],
    monthsShort: ['ජන', 'පෙබ', 'මාර්', 'අප්‍රේල්', 'මැයි', 'ජූනි', 'ජූලි', 'අගෝ', 'සැප්', 'ඔක්', 'නොවැ', 'දෙසැ'],
    today: 'අද',
    clear: 'යලි සකසන්න',
    dateFormat: 'yyyy-mm-dd',
    timeFormat: 'hh:ii aa',
    firstDay: 1
};

const localeSk = {
    days: ['Nedeľa', 'Pondelok', 'Utorok', 'Streda', 'Štvrtok', 'Piatok', 'Sobota'],
    daysShort: ['Ned', 'Pon', 'Uto', 'Str', 'Štv', 'Pia', 'Sob'],
    daysMin: ['Ne', 'Po', 'Ut', 'St', 'Št', 'Pi', 'So'],
    months: ['Január', 'Február', 'Marec', 'Apríl', 'Máj', 'Jún', 'Júl', 'August', 'September', 'Október', 'November', 'December'],
    monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Máj', 'Jún', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    today: 'Dnes',
    clear: 'Vymazať',
    dateFormat: 'dd.MM.yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeSv = {
    days: ['Söndag', 'Måndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lördag'],
    daysShort: ['Sön', 'Mån', 'Tis', 'Ons', 'Tor', 'Fre', 'Lör'],
    daysMin: ['Sö', 'Må', 'Ti', 'On', 'To', 'Fr', 'Lö'],
    months: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni', 'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
    monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    today: 'I dag',
    clear: 'Nollställ',
    dateFormat: 'yyyy-MM-dd',
    timeFormat: 'HH:mm',
    firstDay: 1
};
const localeTh = {
    days: ['วันอาทิตย์', 'วันจันทร์', 'วันอังคาร', 'วันพุธ', 'วันพฤหัสบดี', 'วันศุกร์', 'วันเสาร์'],
    daysShort: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
    daysMin: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
    months: ['มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'],
    monthsShort: ['ม.ค.', 'ก.พ.', 'มี.ค.', 'เม.ย.', 'พ.ค.', 'มิ.ย.', 'ก.ค.', 'ส.ค.', 'ก.ย.', 'ต.ค.', 'พ.ย.', 'ธ.ค.'],
    today: 'วันนี้',
    clear: 'ล้าง',
    dateFormat: 'dd/MM/yyyy',
    timeFormat: 'HH:mm',
    firstDay: 0
};

const localeTr = {
    days: ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'],
    daysShort: ['Pzr', 'Pts', 'Sl', 'Çar', 'Per', 'Cum', 'Cts'],
    daysMin: ['Pa', 'Pt', 'Sl', 'Ça', 'Pe', 'Cu', 'Ct'],
    months: ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran', 'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık'],
    monthsShort: ['Oca', 'Şbt', 'Mrt', 'Nsn', 'Mys', 'Hzr', 'Tmz', 'Ağt', 'Eyl', 'Ekm', 'Ksm', 'Arl'],
    today: 'Bugün',
    clear: 'Temizle',
    dateFormat: 'dd.MM.yyyy',
    timeFormat: 'hh:mm aa',
    firstDay: 1
};



const localeUk = {
    days: ['Неділя', 'Понеділок', 'Вівторок', 'Середа', 'Четвер', 'П’ятниця', 'Субота'],
    daysShort: ['Нед', 'Пнд', 'Вів', 'Срд', 'Чтв', 'Птн', 'Сбт'],
    daysMin: ['Нд', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'],
    months: ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жовтень', 'Листопад', 'Грудень'],
    monthsShort: ['Січ', 'Лют', 'Бер', 'Кві', 'Тра', 'Чер', 'Лип', 'Сер', 'Вер', 'Жов', 'Лис', 'Гру'],
    today: 'Сьогодні',
    clear: 'Очистити',
    dateFormat: 'dd.MM.yyyy',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const localeZh = {
    days: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
    daysShort: ['日', '一', '二', '三', '四', '五', '六'],
    daysMin: ['日', '一', '二', '三', '四', '五', '六'],
    months: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    monthsShort: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    today: '今天',
    clear: '清除',
    dateFormat: 'yyyy-MM-dd',
    timeFormat: 'HH:mm',
    firstDay: 1
};

const consts = {
    days: 'days',
    months: 'months',
    years: 'years',
    day: 'day',
    month: 'month',
    year: 'year',
    nameSpace : 'week-view',
    dragThreshold : 10,
    velocityThreshold : 200,
    widthPerThreshold : 0.3,
    eventChangeViewDate: 'changeViewDate',
    eventChangeCurrentView: 'changeCurrentView',
    eventChangeFocusDate: 'changeFocusDate',
    eventChangeSelectedDate: 'changeSelectedDate',
    eventChangeTime: 'changeTime',
    eventChangeLastSelectedDate: 'changeLastSelectedDate',
    actionSelectDate: 'selectDate',
    actionUnselectDate: 'unselectDate',
    cssClassWeekend: '-weekend-'
};

/* Definición de los valores predeterminados para el selector de fecha. */
const defaults = {
    classes: '',
    inline: false,
    locale: localeEs,
    startDate: new Date(),
    firstDay: '',
    weekends: [6, 0],
    dateFormat: '',
    altField: '',
    altFieldDateFormat: 'T',
    toggleSelected: true,
    keyboardNav: true,
    selectedDates: false,
    container: '',
    isMobile: false,
    visible: false,
    showHeader: true,
    days: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
    timepicker: false,
    onlyTimepicker: false,
    dateTimeSeparator: ' ',
    timeFormat: '',
    minHours: 0,
    maxHours: 24,
    minMinutes: 0,
    maxMinutes: 59,
    hoursStep: 1,
    minutesStep: 1,
    num: 7,
    onSelect: false,
    onChangeViewDate: false,
    onChangeView: false,
    onRenderCell: false,
    onShow: false,
    onHide: false,
    onClickDayName: false,
    position: 'bottom left',
    offset: 12,

    view: consts.days,
    minView: consts.days,

    showOtherMonths: true,
    selectOtherMonths: true,
    moveToOtherMonthsOnSelect: true,

    showOtherYears: true,
    selectOtherYears: true,
    moveToOtherYearsOnSelect: true,

    minDate:new Date() | '',
    maxDate: ''| null,
    disableNavWhenOutOfRange: true,

    multipleDates: false, // Boolean or Number
    multipleDatesSeparator: ', ',
    range: false,
    dynamicRange: true,
    buttons: false,
    monthsField: 'monthsShort',

    showEvent: 'focus',
    autoClose: false,
    // navigation
    prevHtml: '<svg><path d="M 17,12 l -5,5 l 5,5"></path></svg>',
    nextHtml: '<svg><path d="M 14,12 l 5,5 l -5,5"></path></svg>',
    /* Una propiedad del objeto predeterminado. Es un objeto con tres propiedades: días, meses y años. Cada propiedad es
    una cadena. */
    navTitles: {
        days: 'MMMM, <i>yyyy</i>',
        months: 'yyyy',
        years: 'yyyy1 - yyyy2'
    },

    onSelectWeek: (date) => {},
    onChangePeriod: (oldStart, currentStart) => {},
    headerText: date => date.toLocaleDateString(),
    dateText: date => date.getDate(),
    // add class to a cell whose date satisfies certain condition
};

function getEl(el, context = document) {
    return typeof el === 'string' ? context['querySelector'](el) : el;
}

/**
 * Creates HTML DOM element
 * @param {String} [tagName] - element's tag name
 * @param {String} [className]
 * @param {String} [innerHtml]
 * @param {String} [id]
 * @param {Object} [attrs]
 * @returns {HTMLElement}
 */
function createElement({tagName = 'div', className = '', innerHtml = '', id = '', attrs = {}} = {}) {
    let $element = document.createElement(tagName);
    if (className) $element.classList.add(...className.split(' '));
    if (id) $element.id = id;

    if (innerHtml) {
        $element.innerHTML = innerHtml;
    }

    if (attrs) {
        for (let attr in attrs) {
            $element.setAttribute(attr, attrs[attr]);
        }
    }

    return $element;
}

/**
 * Sets multiple attributes of element
 * @param {HTMLElement} el
 * @param {Object} attrs - attributes object
 * @returns {HTMLElement}
 */
function setAttribute(el, attrs) {
    for (let [name, value] of Object.entries(attrs)) {
        el.setAttribute(name, value);
    }
    return el;
}

/**
 * Inserts newElement after targetElement
 * @param {HTMLElement} newElement - element to be inserted
 * @param {HTMLElement} targetElement - after which must be inserted
 * @return {HTMLElement} newElement
 */
function insertAfter(newElement, targetElement) {
    targetElement.parentNode
        .insertBefore(newElement, targetElement.nextSibling);
    return newElement;
}

/**
 * Makes object deep copy
 * @param {Object} obj
 * @return {Object}
 */
function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
}

/**
 * Calculates amount of days in passed date
 * @param {Date} date
 * @return {number}
 */
function getDaysCount(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
}

/**
 * Get detailed date object
 * @param {Date} date
 * @return {{
 *  date: number,
 *  hours: number,
 *  fullDate: (string|*),
 *  month: number,
 *  fullHours: (string|*),
 *  year: number,
 *  week: number,
 *  minutes: number,
 *  fullMonth: string,
 *  day: number,
 *  fullMinutes: (string|*)
 * }}
 */
function getParsedDate(date) {
    let hours = date.getHours(), hours12 = hours % 12 === 0 ? 12 : hours % 12;

    return {
        year: date.getFullYear(),
        month: date.getMonth(),
        fullMonth: (date.getMonth() + 1) < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1, // One based
        date: date.getDate(),
        fullDate: date.getDate() < 10 ? '0' + date.getDate() : date.getDate(),
        day: date.getDay(),
        week: date.getMonth(),
        hours,
        fullHours: getLeadingZeroNum(hours),
        hours12,
        fullHours12: getLeadingZeroNum(hours12),
        minutes: date.getMinutes(),
        fullMinutes: date.getMinutes() < 10 ? '0' + date.getMinutes() : date.getMinutes()
    };
}

/**
 * Converts 1 -> 01
 * @param {Number} num
 * @return {String|Number}
 */
function getLeadingZeroNum(num) {
    return num < 10 ? '0' + num : num;
}

/**
 * Calculates current decade
 * @param {Date} date
 * @return {number[]} - array of two years, decade start - decade end
 */
function getDecade(date) {
    let firstYear = Math.floor(date.getFullYear() / 10) * 10;
    return [firstYear, firstYear + 9];
}

/**
 * Subtract days from date
 * @param {Date} date
 * @param {Number} days
 * @return {Date}
 */
function subDays(date, days) {
    let {year, month, week, date: _date} = getParsedDate(date);
    return new Date(year, month, _date - days);
}

/**
 * Add days to date
 * @param {Date} date
 * @param {Number} days
 * @return {Date}
 */
function addDays(date, days) {
    let {year, month, week, date: _date} = getParsedDate(date);
    return new Date(year, month, _date + days);
}

/**
 * Class names handler, inspired by https://github.com/JedWatson/classnames but very simplified
 * @param {String|Object} classes - class names, could contain strings or object
 */
function classNames(...classes) {
    let classNames = [];

    classes.forEach((c) => {
        if (typeof c === 'object') {
            for (let cName in c) {
                if (c[cName]) {
                    classNames.push(cName);
                }
            }
        } else if (c) {
            classNames.push(c);
        }
    });
    return classNames.join(' ');
}

function toggleClass(el, classes) {
    for (let className in classes) {
        if (classes[className]) {
            el.classList.add(className);
        } else {
            el.classList.remove(className);
        }
    }
}

function addClass(el, ...classes) {
    if (el.length) {
        el.forEach((node) => {
            node.classList.add(...classes);
        });
    } else {
        el.classList.add(...classes);
    }
}

function removeClass(el, ...classes) {
    if (el.length) {
        el.forEach((node) => {
            node.classList.remove(...classes);
        });
    } else {
        el.classList.remove(...classes);
    }
}

/**
 * Checks if passed dates are the same
 * @param {Date} date1
 * @param {Date} date2
 * @param {String} cellType - one of days|months|years
 * @return {boolean}
 */
function isSameDate(date1, date2, cellType = consts.days) {
    if (!date1 || !date2) return false;
    let d1 = getParsedDate(date1), d2 = getParsedDate(date2),

        conditions = {
            [consts.days]: d1.date === d2.date && d1.month === d2.month && d1.year === d2.year,
            [consts.week]: d1.date === d2.date && d1.month === d2.month && d1.year === d2.year,
            [consts.months]: d1.month === d2.month && d1.year === d2.year,
            [consts.years]: d1.year === d2.year
        };

    return conditions[cellType];
}

function isDateBigger(date, comparedDate, loose) {
    let d1 = copyDate(date, false).getTime(), d2 = copyDate(comparedDate, false).getTime();

    return loose ? d1 >= d2 : d1 > d2;
}

function isDateSmaller(date, comparedDate) {
    return !isDateBigger(date, comparedDate, true);
}

/**
 * Copies date
 * @param {Date} date
 * @param {Boolean} [keepTime] - should keep the time in a new date or not
 * @return {Date}
 */
function copyDate(date, keepTime = true) {
    let newDate = new Date(date.getTime());

    if (typeof keepTime === 'boolean' && !keepTime) {
        resetTime(newDate);
    }

    return newDate;
}

function resetTime(date) {
    date.setHours(0, 0, 0, 0);
    return date;
}

function isDateBetween(date, dateFrom, dateTo) {
    return isDateBigger(date, dateFrom) && isDateSmaller(date, dateTo);
}

/**
 * Adds event listener to DOM element
 * @param {HTMLElement|HTMLCollection} el
 * @param {String} type
 * @param {Function} listener
 */
function addEventListener(el, type, listener) {
    if (el instanceof Element && typeof type === 'string' && typeof listener === 'function') {
        if (el.length) {
            el.forEach((e) => {
                e.addEventListener(type, listener);
            });
        } else {
            el.addEventListener(type, listener);
        }
    }
}

/**
 * Finds closest DOM element to passed target. Similar to jQuery.closest()
 * @param {HTMLElement} target
 * @param {String} selector
 * @return {HTMLElement|Boolean}
 */
function closest(target, selector) {
    if (!target || target === document || target instanceof DocumentFragment) return false;

    if (target.matches(selector)) {
        return target;
    }

    return closest(target.parentNode, selector);
}

/**
 * Clamps number between min and max
 * @param {Number} val
 * @param {Number} min
 * @param {Number} max
 * @return {Number}
 */
function clamp(val, min, max,) {
    return val > max ? max : val < min ? min : val;
}

/**
 * Deep merge of objects or arrays, used to merge options
 * @param {object|array} target - target object or array
 * @param {object|array} objects - source objects
 * @return {object|array}
 */
function deepMerge(target, ...objects) {
    objects.filter(o => o).forEach((obj) => {
        for (let [key, value] of Object.entries(obj)) {
            let arrayOrObject = value !== undefined ? value.toString() === ('[object Object]' || '[object Array]') : false;

            if (arrayOrObject) {
                let targetType = target[key] !== undefined ? target[key].toString() : undefined,
                    sourceType = value.toString(), initialValue = Array.isArray(value) ? [] : {};

                // If target and source types are different, e.g. we try to merge number with object,
                // then take source type
                target[key] = target[key] ? targetType !== sourceType ? initialValue : target[key] : initialValue;

                deepMerge(target[key], value);
            } else {
                target[key] = value;
            }
        }
    });

    return target;
}

/**
 * Creates Date object from string or number. If passed param is instance of Date, then just returns it.
 * @param {number|string|Date} date
 * @return {Date | boolean}
 */
function createDate(date) {
    let resultDate = date;

    if (!(date instanceof Date)) {
        resultDate = new Date(date);
    }

    if (isNaN(resultDate.getTime())) {
        console.log(`Unable to convert value "${date}" to Date object`);
        resultDate = false;
    }

    return resultDate;
}

function getWordBoundaryRegExp(sign) {
    let symbols = '\\s|\\.|-|/|\\\\|,|\\$|\\!|\\?|:|;';

    return new RegExp('(^|>|' + symbols + ')(' + sign + ')($|<|' + symbols + ')', 'g');
}

/**
 * change the date by delta
 * @param {Date} date
 * @param {Number} delta
 * @returns {Date}
 */
function changeDate(date, delta) {
    let d = new Date(date)
    d.setDate(d.getDate() + delta)
    return d
}

/**
 * Date formatted in 'yyyy/MM/dd'
 * @param {Date} date
 * @returns {String|Object}
 */
function fullDate(date) {
    if (!Date.parse(date)) {
        // to make comparison behaves correctly
        return null
    }
    let da = new Date(date)
    let y = da.getFullYear()
    let m = da.getMonth() + 1
    let d = da.getDate()
    return `${y}/${m < 10 ? '0' + m : m}/${d < 10 ? '0' + d : d}`
}

function formatStr() {
    var str = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
        str = str.replace(RegExp("\\{" + (i - 1) + "\\}", "gm"), arguments[i]);
    }
    return str;
}

function getMonthName(month = 0, short = false) {
    switch (month) {
        case 0:
            return short ? 'Ene' : 'Enero';

        case 1:
            return short ? 'Feb' : 'Febrero';

        case 2:
            return short ? 'Mar' : 'Marzo';

        case 3:
            return short ? 'Abr' : 'Abril';

        case 4:
            return short ? 'May' : 'Mayo';

        case 5:
            return short ? 'Jun' : 'Junio';

        case 6:
            return short ? 'Jul' : 'Julio';

        case 7:
            return short ? 'Ago' : 'Agosto';

        case 8:
            return short ? 'Sep' : 'Septiembre';

        case 9:
            return short ? 'Oct' : 'Octubre';

        case 10:
            return short ? 'Nov' : 'Noviembre';

        case 11:
            return short ? 'Dic' : 'Diciembre';

        default :
            return '';
    }
}

function getDayName(month = 0, short = false) {
    switch (month) {
        case 0:
            return short ? 'D' : 'Domingo';
        case 1:
            return short ? 'L' : 'Lunes';
        case 2:
            return short ? 'M' : 'Martes';
        case 3:
            return short ? 'M' : 'Miércoles';
        case 4:
            return short ? 'J' : 'Jueves';
        case 5:
            return short ? 'V' : 'Viernes';
        case 6:
            return short ? 'S' : 'Sábado';
        default :
            return '';
    }
}

function getMonthIndex(month = getMonthName((new Date()).getUTCMonth())) {
    if (/enero/gi.test(month)) return 0;
    else if (/febrero/gi.test(month)) return 1;
    else if (/marzo/gi.test(month)) return 2;
    else if (/abril/gi.test(month)) return 3;
    else if (/mayo/gi.test(month)) return 4;
    else if (/junio/gi.test(month)) return 5;
    else if (/julio/gi.test(month)) return 6;
    else if (/agosto/gi.test(month)) return 7;
    else if (/septiembre/gi.test(month)) return 8;
    else if (/octubre/gi.test(month)) return 9;
    else if (/noviembre/gi.test(month)) return 10;
    else if (/diciembre/gi.test(month)) return 11;
    else return -1;
}
class DatepickerButtons {
    constructor({dp, opts}) {
        this.dp = dp;
        this.opts = opts;

        this.init();
    }

    init() {
        this.createElement();
        this.render();
    }

    createElement() {
        this.$el = createElement({className: 'air-datepicker-buttons'});
    }

    destroy() {
        this.$el.parentNode.removeChild(this.$el);
    }

    clearHtml() {
        this.$el.innerHTML = '';
        return this;
    }

    generateButtons() {
        let {buttons} = this.opts;

        if (!Array.isArray(buttons)) {
            buttons = [buttons];
        }

        buttons.forEach((b) => {
            let data = b;

            if (typeof b === 'string' && buttonPresets[b]) {
                data = buttonPresets[b];
            }

            let button = this.createButton(data);
            if (data.onClick) {
                this.attachEventToButton(button, data.onClick);
            }

            this.$el.appendChild(button);
        });

    }

    attachEventToButton(button, onClick) {
        button.addEventListener('click', () => {
            onClick(this.dp);
        });
    }

    /**
     * Creates datepicker button HTML element
     * @param {String|Function} content - button content
     * @param {String} [className]
     * @param {String} [tagName=button]
     * @param {Object} [attrs]
     * @return HTMLElement
     */
    createButton({content, className, tagName = 'button', attrs = {}}) {
        let _content = typeof content === 'function' ? content(this.dp) : content;

        return createElement({
            tagName,
            innerHtml: `<span tabindex='-1'>${_content}</span>`,
            className: classNames('air-datepicker-button', className),
            attrs
        });
    }

    render() {
        this.generateButtons();
    }
}

/* Creación de un objeto buttonPresets con dos propiedades, hoy y claro. */
const buttonPresets = {
    today: {
        content: dp => dp.locale.today,
        onClick: dp => dp.setViewDate(new Date()),
    },
    clear: {
        content: dp => dp.locale.clear,
        onClick: dp => dp.clear()
    }
};

let templates = {
    [consts.days]: '' +
    '<div class="air-datepicker-body--day-names"></div>' +
    `<div class="air-datepicker-body--cells -${consts.days}-"></div>`,
    [consts.months]: `<div class="air-datepicker-body--cells -${consts.months}-"></div>`,
    [consts.years]: `<div class="air-datepicker-body--cells -${consts.years}-"></div>`
};

class DatepickerBody {
    constructor({dp, type, opts}) {
        this.dp = dp;
        this.type = type;
        this.opts = opts;
        this.cells = [];
        this.$el = '';
        this.pressed = false;
        this.isVisible = true;

        this.init();
    }

    init() {
        this._buildBaseHtml();
        if (this.type === consts.days) {
            this.renderDayNames();
        }
        this.render();
        this._bindEvents();
        this._bindDatepickerEvents();
    }

    _bindEvents() {
        let {range, dynamicRange} = this.opts;

        this.$el.addEventListener('mouseover', this.onMouseOverCell);
        this.$el.addEventListener('mouseout', this.onMouseOutCell);
        this.$el.addEventListener('click', this.onClickBody);


        if (range && dynamicRange) {
            this.$el.addEventListener('mousedown', this.onMouseDown);
            this.$el.addEventListener('mousemove', this.onMouseMove);
            window.document.addEventListener('mouseup', this.onMouseUp);
        }

    }

    _bindDatepickerEvents() {
        this.dp.on(consts.eventChangeViewDate, this.onChangeViewDate);
        this.dp.on(consts.eventChangeCurrentView, this.onChangeCurrentView);
    }

    _buildBaseHtml() {
        this.$el = createElement({
            className: `air-datepicker-body -${this.type}-`,
            innerHtml: templates[this.type]
        });

        this.$names = getEl('.air-datepicker-body--day-names', this.$el);
        this.$cells = getEl('.air-datepicker-body--cells', this.$el);
    }

    _getDayNamesHtml(firstDay = this.dp.locale.firstDay) {
        let html = '',
            isWeekend = this.dp.isWeekend,
            {onClickDayName} = this.opts,
            curDay = firstDay,
            i = 0;

        while (i < 7) {
            let day = curDay % 7;
            let className = classNames('air-datepicker-body--day-name', {
                [consts.cssClassWeekend]: isWeekend(day),
                '-clickable-': !!onClickDayName
            });
            let dayName = this.dp.locale.daysMin[day];

            html += `<div class="${className}" data-day-index='${day}'>${dayName}</div>`;

            i++;
            curDay++;
        }
        return html;
    }

    _getDaysCells() {
        let {viewDate, locale: {firstDay}} = this.dp,
            totalMonthDays = getDaysCount(viewDate),
            {year, month} = getParsedDate(viewDate),
            firstMonthDay = new Date(year, month, 1),
            lastMonthDay = new Date(year, month, totalMonthDays),
            daysFromPrevMonth = firstMonthDay.getDay() - firstDay,
            daysFromNextMonth = 6 - lastMonthDay.getDay() + firstDay;

        daysFromPrevMonth = daysFromPrevMonth < 0 ? daysFromPrevMonth + 7 : daysFromPrevMonth;
        daysFromNextMonth = daysFromNextMonth > 6 ? daysFromNextMonth - 7 : daysFromNextMonth;

        let firstRenderDate = subDays(firstMonthDay, daysFromPrevMonth),
            totalRenderDays = totalMonthDays + daysFromPrevMonth + daysFromNextMonth,
            firstRenderDayDate = firstRenderDate.getDate(),
            {year: renderYear, month: renderMonth} = getParsedDate(firstRenderDate),
            i = 0;

        while (i < totalRenderDays) {
            let date = new Date(renderYear, renderMonth, firstRenderDayDate + i);
            this._generateCell(date);
            i++;
        }
    }

    _generateCell(date) {
        let {type, dp, opts} = this;
        let cell = new DatepickerCell({
            type,
            dp,
            opts,
            date,
            body: this
        });

        this.cells.push(cell);

        return cell;
    }

    _generateDayCells() {
        this._getDaysCells();
    }

    _generateMonthCells() {
        let totalMonths = 12,
            {year} = this.dp.parsedViewDate,
            currentMonth = 0;

        while (currentMonth < totalMonths) {
            this.cells.push(this._generateCell(new Date(year, currentMonth)));
            currentMonth++;
        }
    }

    _generateYearCells() {
        let decade = getDecade(this.dp.viewDate),
            firstYear = decade[0] - 1,
            lastYear = decade[1] + 1,
            year = firstYear;

        while (year <= lastYear) {
            this.cells.push(this._generateCell(new Date(year, 0)));
            year++;
        }
    }

    renderDayNames() {
        this.$names.innerHTML = this._getDayNamesHtml();
    }

    _generateCells() {
        switch (this.type) {
            case consts.days:
                this._generateDayCells();
                break;
            case consts.months:
                this._generateMonthCells();
                break;
            case consts.years:
                this._generateYearCells();
                break;
        }
    }

    show() {
        this.isVisible = true;
        this.$el.classList.remove('-hidden-');
    }

    hide() {
        this.isVisible = false;
        this.$el.classList.add('-hidden-');
    }

    destroyCells() {
        this.cells.forEach(c => c.destroy());
        this.cells = [];
        this.$cells.innerHTML = '';
    }

    destroy() {
        this.destroyCells();
        this.dp.off(consts.eventChangeViewDate, this.onChangeViewDate);
        this.dp.off(consts.eventChangeCurrentView, this.onChangeCurrentView);
    }

    handleClick = (e) => {
        let $cell = e.target;
        let cell = $cell.adpCell;
        if (cell.isDisabled) return;

        if (!this.dp.isMinViewReached) {
            this.dp.down();
            return;
        }

        let alreadySelectedDate = this.dp._checkIfDateIsSelected(cell.date, cell.type);

        if (alreadySelectedDate) {
            this.dp._handleAlreadySelectedDates(alreadySelectedDate, cell.date);
        } else {
            this.dp.selectDate(cell.date);
        }
    }

    handleDayNameClick = (e) => {
        let index = e.target.getAttribute('data-day-index');

        this.opts.onClickDayName({
            dayIndex: Number(index),
            datepicker: this.dp
        });
    }

    onChangeCurrentView = (view) => {
        if (view !== this.type) {
            this.hide();
        } else {
            this.show();
            this.render();
        }
    }

    onMouseOverCell = (e) => {
        let $cell = closest(e.target, '.air-datepicker-cell');
        this.dp.setFocusDate($cell ? $cell.adpCell.date : false);
    }

    onMouseOutCell = () => {
        this.dp.setFocusDate(false);
    }

    onClickBody = (e) => {
        let {onClickDayName} = this.opts;
        let target = e.target;

        if (target.closest('.air-datepicker-cell')) {
            this.handleClick(e);
        }

        if (onClickDayName && target.closest('.air-datepicker-body--day-name')) {
            this.handleDayNameClick(e);
        }
    }

    onMouseDown = (e) => {
        this.pressed = true;

        let $cell = closest(e.target, '.air-datepicker-cell'),
            cell = $cell && $cell.adpCell;

        if (isSameDate(cell.date, this.dp.rangeDateFrom)) {
            this.rangeFromFocused = true;
        }
        if (isSameDate(cell.date, this.dp.rangeDateTo)) {
            this.rangeToFocused = true;
        }
    }

    onMouseMove = (e) => {
        if (!this.pressed || !this.dp.isMinViewReached) return;
        e.preventDefault();

        let $cell = closest(e.target, '.air-datepicker-cell'),
            cell = $cell && $cell.adpCell,
            {selectedDates, rangeDateTo, rangeDateFrom} = this.dp;

        if (!cell || cell.isDisabled) return;

        let {date} = cell;

        // Allow user to change selected range
        if (selectedDates.length === 2) {
            // Add hours and minute to new selected date, to update time sliders properly
            if (this.rangeFromFocused && !isDateBigger(date, rangeDateTo)) {
                let {hours, minutes} = getParsedDate(rangeDateFrom);
                date.setHours(hours);
                date.setMinutes(minutes);

                this.dp.rangeDateFrom = date;
                this.dp.replaceDate(rangeDateFrom, date);
            }
            if (this.rangeToFocused && !isDateSmaller(date, rangeDateFrom)) {
                let {hours, minutes} = getParsedDate(rangeDateTo);
                date.setHours(hours);
                date.setMinutes(minutes);

                this.dp.rangeDateTo = date;
                this.dp.replaceDate(rangeDateTo, date);
            }
        }
    }

    onMouseUp = () => {
        this.pressed = false;
        this.rangeFromFocused = false;
        this.rangeToFocused = false;
    }

    onChangeViewDate = (date, oldViewDate) => {
        // Handle only visible views
        if (!this.isVisible) return;

        let decade1 = getDecade(date),
            decade2 = getDecade(oldViewDate);

        // Prevent unnecessary cell rendering when going up or down to next view
        switch (this.dp.currentView) {
            case (consts.days):
                if (isSameDate(date, oldViewDate, consts.months)) {
                    return;
                }
                break;
            case (consts.months):
                if (isSameDate(date, oldViewDate, consts.years)) {
                    return;
                }
                break;
            case (consts.years):
                if (decade1[0] === decade2[0] && decade1[1] === decade2[1]) {
                    return;
                }
                break;
        }

        this.render();
    }

    render = () => {
        this.destroyCells();
        this._generateCells();
        this.cells.forEach((c) => {
            this.$cells.appendChild(c.render());
        });
    }
}

class DatepickerCell {
    constructor({type, date, dp, opts, body} = {}) {
        this.type = type;
        /* Obtener la versión singular del tipo. */
        this.singleType = this.type.slice(0, -1); // days -> day etc.'`
        this.date = date;
        this.dp = dp;
        this.opts = opts;
        this.body = body;
        this.customData = false;

        this.init();
    }

    /**
     * La función inicializa el selector de fecha creando el elemento, vinculando los eventos del selector de fecha,
     * manejando el estado de enfoque inicial, manejando el estado seleccionado y manejando el estado de rango
     */
    init() {
        let {range, onRenderCell} = this.opts;

        if (onRenderCell) {
            this.customData = onRenderCell({
                date: this.date,
                cellType: this.singleType,
                datepicker: this.dp,
            });
        }

        this._createElement();
        this._bindDatepickerEvents();
        this._handleInitialFocusStatus();
        if (this.dp.hasSelectedDates) {
            this._handleSelectedStatus();
            if (range) {
                this._handleRangeStatus();
            }
        }
    }

    _bindDatepickerEvents() {
        this.dp.on(consts.eventChangeSelectedDate, this.onChangeSelectedDate);
        this.dp.on(consts.eventChangeFocusDate, this.onChangeFocusDate);
    }

    unbindDatepickerEvents() {
        this.dp.off(consts.eventChangeSelectedDate, this.onChangeSelectedDate);
        this.dp.off(consts.eventChangeFocusDate, this.onChangeFocusDate);
    }

    /**
     * Crea un elemento DOM con el nombre de clase de la fecha actual y establece los atributos de datos del año, mes y
     * fecha.
     */
    _createElement() {
        let {year, month, date} = getParsedDate(this.date);

        this.$cell = createElement({
            className: this._getClassName(),
            attrs: {
                'data-year': year,
                'data-month': month,
                'notification-cell': date,
            }
        });
    }

    /**
     * Devuelve una cadena de nombres de clase para la celda del selector de fechas.
     * @returns Una cadena de nombres de clase.
     */
    _getClassName() {
        /* Creación de un nuevo objeto de fecha. */
        let currentDate = new Date();
        /* Desestructuración del objeto `this.opts`. */
        let {selectOtherMonths, selectOtherYears} = this.opts;
        /* Destrucción del objeto `this.dp`. */
        let {minDate, maxDate} = this.dp;
        /* Desestructurar el objeto `getParsedDate(this.date)` en la variable `day`. */
        let {day} = getParsedDate(this.date);
        /* Comprobando si la fecha está fuera del rango mínimo y máximo. */
        let isOutOfMinMaxRange = this._isOutOfMinMaxRange();
        /* Usar el operador de encadenamiento opcional para verificar si la propiedad `deshabilitada` existe en el objeto
        `customData`. */
        let disabled = this.customData?.disabled;

        /* Creación de una cadena de nombres de clase. */
        let classNameCommon = classNames(
            'air-datepicker-cell',
            `-${this.singleType}-`, // days -> day etc.'`
            {
                '-current-': isSameDate(currentDate, this.date, this.type),
                '-min-date-': minDate && isSameDate(minDate, this.date, this.type),
                '-max-date-': maxDate && isSameDate(maxDate, this.date, this.type),
            }
        );
        let classNameType = '';

        /* Una declaración de cambio. */
        switch (this.type) {
            /* Una declaración de cambio. */
            case consts.days:
                classNameType = classNames({
                    '-other-month-': this.isOtherMonth,
                    '-disabled-': this.isOtherMonth && !selectOtherMonths || isOutOfMinMaxRange || disabled
                });
                break;
            /* Creación de un nombre de clase para los meses. */
            case consts.months:
                classNameType = classNames({
                    '-disabled-': isOutOfMinMaxRange || disabled
                });
                break;
            /* Crear un nombre de clase para los años. */
            case consts.years:
                classNameType = classNames({
                    '-other-decade-': this.isOtherDecade,
                    '-disabled-': isOutOfMinMaxRange || (this.isOtherDecade && !selectOtherYears) || disabled
                });
                break;
        }

        return classNames(classNameCommon, classNameType, this.customData?.classes);
    }

    _getHtml() {
        let {year, month, date} = getParsedDate(this.date);
        let {showOtherMonths, showOtherYears} = this.opts;

        if (this.customData?.html) {
            return this.customData.html;
        }

        switch (this.type) {
            case consts.days:
                return !showOtherMonths && this.isOtherMonth ? '' : date;
            case consts.months:
                return this.dp.locale[this.opts.monthsField][month];
            case consts.years:
                return !showOtherYears && this.isOtherDecade ? '' : year;
        }
    }

    _isOutOfMinMaxRange() {
        let {minDate, maxDate} = this.dp;
        let {type, date: cellDate} = this;
        let {month, year, date} = getParsedDate(cellDate);
        let isDay = type === consts.days;
        let isYear = type === consts.years;

        //Dado que en las celdas de los meses la fecha se establece en el primer día del mes debemos cambiar su valor a partir de las fechas mínimas o máximas
        //para poder marcar la celda como desactivada correctamente
        //Lo mismo ocurre con las celdas del año
        let cellMinDate = minDate
            ? new Date(year, isYear ? minDate.getMonth() : month, isDay ? date : minDate.getDate())
            : false;
        let cellMaxDate = maxDate
            ? new Date(year, isYear ? maxDate.getMonth() : month, isDay ? date : maxDate.getDate())
            : false;

        if (minDate && maxDate) {
            return isDateSmaller(cellMinDate, minDate) || isDateBigger(cellMaxDate, maxDate);
        }

        if (minDate) {
            return isDateSmaller(cellMinDate, minDate);
        }

        if (maxDate) {
            return isDateBigger(cellMaxDate, maxDate);
        }
    }

    destroy() {
        this.unbindDatepickerEvents();
    }

    focus = () => {
        this.$cell.classList.add('-focus-');
        this.focused = true;
    }

    removeFocus = () => {
        this.$cell.classList.remove('-focus-');
        this.focused = false;
    }

    select = () => {
        this.$cell.classList.add('-selected-');
        this.selected = true;
    }

    removeSelect = () => {
        this.$cell.classList.remove('-selected-', '-range-from-', '-range-to-');
        this.selected = false;
    }

    _handleRangeStatus() {
        let {rangeDateFrom, rangeDateTo} = this.dp;
        let classes = classNames({
            '-in-range-': rangeDateFrom && rangeDateTo && isDateBetween(this.date, rangeDateFrom, rangeDateTo),
            '-range-from-': rangeDateFrom && isSameDate(this.date, rangeDateFrom, this.type),
            '-range-to-': rangeDateTo && isSameDate(this.date, rangeDateTo, this.type)
        });

        this.$cell.classList.remove('-range-from-', '-range-to-', '-in-range-');

        if (classes) {
            this.$cell.classList.add(...classes.split(' '));
        }
    }

    _handleSelectedStatus() {
        let selected = this.dp._checkIfDateIsSelected(this.date, this.type);
        if (selected) {
            this.select();
        } else if (!selected && this.selected) {
            this.removeSelect();
        }
    }

    _handleInitialFocusStatus() {
        let datesAreSame = isSameDate(this.dp.focusDate, this.date, this.type);

        if (datesAreSame) {
            this.focus();
        }
    }

    get isDisabled() {
        return this.$cell.matches('-disabled-');

    }

    get isOtherMonth() {
        return this.dp.isOtherMonth(this.date);
    }

    get isOtherDecade() {
        return this.dp.isOtherDecade(this.date);
    }

    onChangeSelectedDate = () => {
        if (this.isDisabled) return;

        this._handleSelectedStatus();
        if (this.opts.range) {
            this._handleRangeStatus();
        }
    }

    onChangeFocusDate = (date) => {
        if (!date) {
            if (this.focused) {
                this.removeFocus();
            }
            return;
        }

        let datesAreSame = isSameDate(date, this.date, this.type);

        if (datesAreSame) {
            this.focus();
        } else if (!datesAreSame && this.focused) {
            this.removeFocus();
        }

        if (this.opts.range) {
            this._handleRangeStatus();
        }
    }

    render = () => {
        this.$cell.innerHTML = this._getHtml();
        this.$cell.adpCell = this;
        return this.$cell;
    }
}

class DatepickerKeyboard {
    pressedKeys = new Set();

    hotKeys = new Map(
        [
            [[['Control', 'ArrowRight'], ['Control', 'ArrowUp']], dateParts => dateParts.month++],
            [[['Control', 'ArrowLeft'], ['Control', 'ArrowDown']], dateParts => dateParts.month--],
            [[['Shift', 'ArrowRight'], ['Shift', 'ArrowUp']], dateParts => dateParts.year++],
            [[['Shift', 'ArrowLeft'], ['Shift', 'ArrowDown']], dateParts => dateParts.year--],
            [[['Alt', 'ArrowRight'], ['Alt', 'ArrowUp']], dateParts => dateParts.year += 10],
            [[['Alt', 'ArrowLeft'], ['Alt', 'ArrowDown']], dateParts => dateParts.year -= 10],
            [['Control', 'Shift', 'ArrowUp'], (dateParts, dp) => dp.up()],
        ]
    )

    constructor({dp, opts}) {
        this.dp = dp;
        this.opts = opts;

        this.init();
    }

    init() {
        this.bindKeyboardEvents();
    }

    bindKeyboardEvents() {
        let {$el} = this.dp;

        $el.addEventListener('keydown', this.onKeyDown);
        $el.addEventListener('keyup', this.onKeyUp);
    }

    destroy() {
        let {$el} = this.dp;

        $el.removeEventListener('keydown', this.onKeyDown);
        $el.removeEventListener('keyup', this.onKeyUp);
        this.hotKeys = null;
        this.pressedKeys = null;
    }

    getInitialFocusDate() {
        let {focusDate, currentView, selectedDates, parsedViewDate: {year, month}} = this.dp;
        let potentialFocused = focusDate || selectedDates[selectedDates.length - 1];

        if (!potentialFocused) {
            switch (currentView) {
                case consts.days:
                    potentialFocused = new Date(year, month, new Date().getDate());
                    break;
                case consts.months:
                    potentialFocused = new Date(year, month, 1);
                    break;
                case consts.years:
                    potentialFocused = new Date(year, 0, 1);
                    break;
            }
        }

        return potentialFocused;
    }

    focusNextCell(keyName) {
        let initialFocusDate = this.getInitialFocusDate(),
            {currentView} = this.dp,
            {days, months, years} = consts,
            parsedFocusDate = getParsedDate(initialFocusDate),
            y = parsedFocusDate.year,
            m = parsedFocusDate.month,
            d = parsedFocusDate.date;

        switch (keyName) {
            case 'ArrowLeft':
                currentView === days ? (d -= 1) : '';
                currentView === months ? (m -= 1) : '';
                currentView === years ? (y -= 1) : '';
                break;
            case 'ArrowUp':
                currentView === days ? (d -= 7) : '';
                currentView === months ? (m -= 3) : '';
                currentView === years ? (y -= 4) : '';
                break;
            case 'ArrowRight':
                currentView === days ? (d += 1) : '';
                currentView === months ? (m += 1) : '';
                currentView === years ? (y += 1) : '';
                break;
            case 'ArrowDown':
                currentView === days ? (d += 7) : '';
                currentView === months ? (m += 3) : '';
                currentView === years ? (y += 4) : '';
                break;
        }

        let newFocusedDate = this.dp.getClampedDate(new Date(y, m, d));
        this.dp.setFocusDate(newFocusedDate, {viewDateTransition: true});
    }

    registerKey(keyName) {
        this.pressedKeys.add(keyName);
    }

    removeKey(keyName) {
        this.pressedKeys.delete(keyName);
    }

    handleHotKey = (combination) => {
        let fn = this.hotKeys.get(combination),
            dateParts = getParsedDate(this.getInitialFocusDate());

        fn(dateParts, this.dp);

        let {year, month, date} = dateParts;

        let totalDaysInNextMonth = getDaysCount(new Date(year, month));

        if (totalDaysInNextMonth < date) {
            date = totalDaysInNextMonth;
        }

        let newFocusedDate = this.dp.getClampedDate(new Date(year, month, date));

        this.dp.setFocusDate(newFocusedDate, {viewDateTransition: true});
    }

    /**
     * Checks if one of hot key is pressed. If so, then returns array of matched combinations
     * @return {boolean | Array}
     */
    isHotKeyPressed = () => {
        let hotKeyIsPressed = false;
        let pressedKeysLength = this.pressedKeys.size;
        let isAllKeysArePressed = key => this.pressedKeys.has(key);

        for (let [combinations] of this.hotKeys) {
            if (hotKeyIsPressed) break;
            if (Array.isArray(combinations[0])) {
                combinations.forEach((combination) => {
                    if (hotKeyIsPressed || pressedKeysLength !== combination.length) return;
                    hotKeyIsPressed = combination.every(isAllKeysArePressed) && combinations;
                });
            } else {
                if (pressedKeysLength !== combinations.length) continue;
                hotKeyIsPressed = combinations.every(isAllKeysArePressed) && combinations;
            }
        }

        return hotKeyIsPressed;
    }

    isArrow = (keyCode) => {
        return keyCode >= 37 && keyCode <= 40;
    }

    onKeyDown = (e) => {
        let {key, which} = e;
        let {dp, dp: {focusDate}, opts} = this;

        this.registerKey(key);

        let pressedHotKey = this.isHotKeyPressed();

        if (pressedHotKey) {
            e.preventDefault();
            this.handleHotKey(pressedHotKey);
            return;
        }

        if (this.isArrow(which)) {
            e.preventDefault();
            this.focusNextCell(key);
            return;
        }

        if (key === 'Enter') {
            if (dp.currentView !== opts.minView) {
                dp.down();
                return;
            }
            if (focusDate) {
                let alreadySelectedDate = dp._checkIfDateIsSelected(focusDate);
                if (!alreadySelectedDate) {
                    dp.selectDate(focusDate);
                } else {
                    dp._handleAlreadySelectedDates(alreadySelectedDate, focusDate);
                }
                return;
            }
        }

        if (key === 'Escape') {
            this.dp.hide();
        }
    }

    onKeyUp = (e) => {
        this.removeKey(e.key);
    }
}

class DatepickerNav {
    constructor({dp, opts}) {
        this.dp = dp;
        this.opts = opts;

        this.init();
    }

    init() {
        this._createElement();
        this._buildBaseHtml();
        this._defineDOM();

        this.render();

        this.handleNavStatus();
        this._bindEvents();
        this._bindDatepickerEvents();
    }

    _defineDOM() {
        this.$title = getEl('.air-datepicker-nav--title', this.$el);
        this.$prev = getEl('[data-action="prev"]', this.$el);
        this.$next = getEl('[data-action="next"]', this.$el);
    }

    _bindEvents() {
        this.$el.addEventListener('click', this.onClickNav);
        this.$title.addEventListener('click', this.onClickNavTitle);
    }

    _bindDatepickerEvents() {
        this.dp.on(consts.eventChangeViewDate, this.onChangeViewDate);
        this.dp.on(consts.eventChangeCurrentView, this.onChangeCurrentView);

        if (this.isNavIsFunction) {
            // Wait till time is added to date
            this.dp.on(consts.eventChangeSelectedDate, this.renderDelay);

            if (this.dp.opts.timepicker) {
                this.dp.on(consts.eventChangeTime, this.render);
            }
        }
    }

    destroy() {
        this.dp.off(consts.eventChangeViewDate, this.onChangeViewDate);
        this.dp.off(consts.eventChangeCurrentView, this.onChangeCurrentView);
        if (this.isNavIsFunction) {
            this.dp.off(consts.eventChangeSelectedDate, this.renderDelay);
            if (this.dp.opts.timepicker) {
                this.dp.off(consts.eventChangeTime, this.render);
            }
        }
    }

    _createElement() {
        this.$el = createElement({
            tagName: 'nav',
            className: 'air-datepicker-nav'
        });
    }

    _getTitle() {
        let {dp, opts} = this;
        let template = opts.navTitles[dp.currentView];

        if (typeof template === 'function') {
            return template(dp);
        }

        return dp.formatDate(dp.viewDate, template);
    }

    handleNavStatus() {
        let {disableNavWhenOutOfRange} = this.opts;
        let {minDate, maxDate} = this.dp;
        if (!(minDate || maxDate) || !disableNavWhenOutOfRange) return;

        let { year, month} = this.dp.parsedViewDate;
        let minDateParsed = minDate ? getParsedDate(minDate) : false;
        let maxDateParsed = maxDate ? getParsedDate(maxDate) : false;

        switch (this.dp.currentView) {
            case consts.days:
                if (minDate && (minDateParsed.month >= month && minDateParsed.year >= year)) {
                    this._disableNav('prev');
                }
                if (maxDate && maxDateParsed.month <= month && maxDateParsed.year <= year) {
                    this._disableNav('next');
                }
                break;
            case consts.months:
                if (minDate && minDateParsed.year >= year) {
                    this._disableNav('prev');
                }
                if (maxDate && maxDateParsed.year <= year) {
                    this._disableNav('next');
                }
                break;
            case consts.years: {
                let decade = getDecade(this.dp.viewDate);
                if (minDate && minDateParsed.year >= decade[0]) {
                    this._disableNav('prev');
                }
                if (maxDate && maxDateParsed.year <= decade[1]) {
                    this._disableNav('next');
                }
                break;
            }
        }
    }

    _disableNav(actionName) {
        getEl('[data-action="' + actionName + '"]', this.$el).classList.add('-disabled-');
    }

    _resetNavStatus() {
        removeClass(this.$el.querySelectorAll('.air-datepicker-nav--action'), '-disabled-');
    }

    onClickNav = (e) => {
        let $item = closest(e.target, '.air-datepicker-nav--action');
        if (!$item) return;

        let actionName = $item.dataset.action;

        this.dp[actionName]();
    }

    onChangeViewDate = () => {
        this.render();
        this._resetNavStatus();
        this.handleNavStatus();
    }

    onChangeCurrentView = () => {
        this.render();
        this._resetNavStatus();
        this.handleNavStatus();
    }

    onClickNavTitle = () => {
        if (this.dp.isFinalView) return;
        this.dp.up();
    }

    _buildBaseHtml() {
        let {prevHtml, nextHtml} = this.opts;

        this.$el.innerHTML = '' +
            `<div class="air-datepicker-nav--action" data-action="prev">${prevHtml}</div>` +
            '<div class="air-datepicker-nav--title"></div>' +
            `<div class="air-datepicker-nav--action" data-action="next">${nextHtml}</div>`;
    }

    get isNavIsFunction() {
        let {navTitles} = this.opts;

        return Object.keys(navTitles).find((view) => {
            return typeof navTitles[view] === 'function';
        });
    }

    update = () => {
        let {prevHtml, nextHtml} = this.opts;

        this.$prev.innerHTML = prevHtml;
        this.$next.innerHTML = nextHtml;

        this._resetNavStatus();
        this.render();
        this.handleNavStatus();
    }

    renderDelay = () => {
        setTimeout(this.render);
    }

    render = () => {
        this.$title.innerHTML = this._getTitle();

        toggleClass(this.$title, {
            '-disabled-': this.dp.isFinalView
        });
    }
}

/**
 * Timepicker
 *
 * How does it work:
 * Timepicker has its own hour and minute values. At the start they will be equal to current time, or to min/max date values.
 * When user selects date, timepicker add its values to the date (when consts.eventChangeSelectedDate is triggered).
 * When lastSelectedDate is changed (e.g. when user clicks on already selected date in multiple dates mode or in range mode)
 * then hour and minute values are taken from this date and stored in a timepicker instance.
 *
 */
class DatepickerTime {
    constructor({opts, dp} = {}) {
        this.opts = opts;
        this.dp = dp;
        let {timeFormat} = this.dp.locale;

        if (timeFormat && (timeFormat.match(getWordBoundaryRegExp('h')) || timeFormat.match(getWordBoundaryRegExp('hh')))) {
            this.ampm = true;
        }

        this.init();
    }

    init() {
        this.setTime(this.dp.lastSelectedDate || this.dp.viewDate);
        this.createElement();
        this.buildHtml();
        this.defineDOM();
        this.render();

        this.bindDatepickerEvents();
        this.bindDOMEvents();
    }

    bindDatepickerEvents() {
        this.dp.on(consts.eventChangeSelectedDate, this.onChangeSelectedDate);
        this.dp.on(consts.eventChangeLastSelectedDate, this.onChangeLastSelectedDate);
    }

    bindDOMEvents() {
        let changeEvent = 'input';
        if (navigator.userAgent.match(/trident/gi)) {
            changeEvent = 'change';
        }

        addEventListener(this.$ranges, changeEvent, this.onChangeInputRange);
        addEventListener(this.$ranges, 'mouseenter', this.onMouseEnterLeave);
        addEventListener(this.$ranges, 'mouseleave', this.onMouseEnterLeave);
        addEventListener(this.$ranges, 'focus', this.onFocus);
        addEventListener(this.$ranges, 'mousedown', this.onFocus);
        addEventListener(this.$ranges, 'blur', this.onBlur);
    }

    createElement() {
        this.$el = createElement({className: classNames('air-datepicker-time', {'-am-pm-': this.dp.ampm})});
    }

    destroy() {
        this.dp.off(consts.eventChangeSelectedDate, this.onChangeSelectedDate);
        this.dp.off(consts.eventChangeLastSelectedDate, this.onChangeLastSelectedDate);
        this.$el.parentNode.removeChild(this.$el);
    }

    buildHtml() {
        let {
            ampm, hours, displayHours, minutes, minHours, minMinutes, maxHours, maxMinutes, dayPeriod,
            opts: {hoursStep, minutesStep}
        } = this;

        this.$el.innerHTML = '' +
            '<div class="air-datepicker-time--current">' +
            `   <span class="air-datepicker-time--current-hours">${getLeadingZeroNum(displayHours)}</span>` +
            '   <span class="air-datepicker-time--current-colon">:</span>' +
            `   <span class="air-datepicker-time--current-minutes">${getLeadingZeroNum(minutes)}</span>` +
            `   ${ampm ? `<span class='air-datepicker-time--current-ampm'>${dayPeriod}</span>` : ''}` +
            '</div>' +
            '<div class="air-datepicker-time--sliders">' +
            '   <div class="air-datepicker-time--row">' +
            // eslint-disable-next-line max-len
            `      <input type="range" name="hours" value="${hours}" min="${minHours}" max="${maxHours}" step="${hoursStep}"/>` +
            '   </div>' +
            '   <div class="air-datepicker-time--row">' +
            // eslint-disable-next-line max-len
            `      <input type="range" name="minutes" value="${minutes}" min="${minMinutes}" max="${maxMinutes}" step="${minutesStep}"/>` +
            '   </div>' +
            '</div>';
    }

    defineDOM() {
        let getElWithContext = selector => getEl(selector, this.$el);

        this.$ranges = this.$el.querySelectorAll('[type="range"]');
        this.$hours = getElWithContext('[name="hours"]');
        this.$minutes = getElWithContext('[name="minutes"]');
        this.$hoursText = getElWithContext('.air-datepicker-time--current-hours');
        this.$minutesText = getElWithContext('.air-datepicker-time--current-minutes');
        this.$ampm = getElWithContext('.air-datepicker-time--current-ampm');
    }


    setTime(date) {
        this.setMinMaxTime(date);
        this.setCurrentTime(date);
    }

    addTimeToDate(date) {
        if (!date) return;
        date.setHours(this.hours);
        date.setMinutes(this.minutes);
    }

    setMinMaxTime(date) {
        this.setMinMaxTimeFromOptions();

        if (date) {
            let {minDate, maxDate} = this.dp;
            if (minDate && isSameDate(date, minDate)) {
                this.setMinTimeFromMinDate(minDate);
            }
            if (maxDate && isSameDate(date, maxDate)) {
                this.setMaxTimeFromMaxDate(maxDate);
            }
        }
    }

    setCurrentTime(date) {
        let {hours, minutes} = date ? getParsedDate(date) : this;

        this.hours = clamp(hours, this.minHours, this.maxHours);
        this.minutes = clamp(minutes, this.minMinutes, this.maxMinutes);
    }

    setMinMaxTimeFromOptions() {
        let maxHoursPossible = 23,
            maxMinutesPossible = 59,
            {minHours, minMinutes, maxHours, maxMinutes} = this.opts;

        this.minHours = clamp(minHours, 0, maxHoursPossible);
        this.minMinutes = clamp(minMinutes, 0, maxMinutesPossible);
        this.maxHours = clamp(maxHours, 0, maxHoursPossible);
        this.maxMinutes = clamp(maxMinutes, 0, maxMinutesPossible);
    }

    setMinTimeFromMinDate(date) {
        let {lastSelectedDate} = this.dp;

        this.minHours = date.getHours();

        if (lastSelectedDate && lastSelectedDate.getHours() > date.getHours()) {
            this.minMinutes = this.opts.minMinutes;
        } else {
            this.minMinutes = date.getMinutes();
        }
    }

    setMaxTimeFromMaxDate(date) {
        let {lastSelectedDate} = this.dp;

        this.maxHours = date.getHours();

        if (lastSelectedDate && lastSelectedDate.getHours() < date.getHours()) {
            this.maxMinutes = this.opts.maxMinutes;
        } else {
            this.maxMinutes = date.getMinutes();
        }
    }

    /**
     * Calculates valid hour value to display in text input and datepicker's body.
     * @param date {Date|Number} - date or hours
     * @param [ampm] {Boolean} - 12 hours mode
     * @returns {{hours: number, dayPeriod: string}}
     */
    getDayPeriod(date, ampm) {
        let _date = date,
            hours = Number(date);

        if (date instanceof Date) {
            _date = getParsedDate(date);
            hours = Number(_date.hours);
        }

        let _ampm = ampm || this.ampm,
            dayPeriod = 'am';

        if (_ampm) {
            switch (true) {
                case hours === 12:
                    dayPeriod = 'pm';
                    break;
                case hours > 11:
                    dayPeriod = 'pm';
                    break;
            }

            hours = hours % 12 === 0 ? 12 : hours % 12;
        }

        return {
            hours,
            dayPeriod
        };
    }

    updateSliders() {
        setAttribute(this.$hours, {
            min: this.minHours,
            max: this.maxHours
        }).value = this.hours;

        setAttribute(this.$minutes, {
            min: this.minMinutes,
            max: this.maxMinutes
        }).value = this.minutes;
    }

    updateText() {
        this.$hoursText.innerHTML = getLeadingZeroNum(this.displayHours);
        this.$minutesText.innerHTML = getLeadingZeroNum(this.minutes);

        if (this.ampm) {
            this.$ampm.innerHTML = this.dayPeriod;
        }
    }

    toggleTimepickerIsActive = (value) => {
        this.dp.timepickerIsActive = value;
    }

    onChangeSelectedDate = ({date, updateTime = false}) => {
        if (!date) return;

        // Check if date is minDate or maxDate and set timepicker's time to corresponding values
        this.setMinMaxTime(date);
        this.setCurrentTime(updateTime ? date : false);

        this.addTimeToDate(date);
    }

    onChangeLastSelectedDate = (date) => {
        if (!date) return;

        this.setTime(date);
        this.render();
    }

    onChangeInputRange = (e) => {
        let $target = e.target,
            name = $target.getAttribute('name');

        this[name] = $target.value;
        this.updateText();

        this.dp.trigger(consts.eventChangeTime, {
            hours: this.hours,
            minutes: this.minutes
        });
    }

    onMouseEnterLeave = (e) => {
        let name = e.target.getAttribute('name'),
            $el = this.$minutesText;

        if (name === 'hours') {
            $el = this.$hoursText;
        }

        $el.classList.toggle('-focus-');
    }

    onFocus = () => {
        this.toggleTimepickerIsActive(true);
    }

    onBlur = () => {
        this.toggleTimepickerIsActive(false);
    }

    set hours(val) {
        this._hours = val;

        let {hours, dayPeriod} = this.getDayPeriod(val);

        this.displayHours = hours;
        this.dayPeriod = dayPeriod;
    }

    get hours() {
        return this._hours;
    }

    render() {
        this.updateSliders();
        this.updateText();
    }
}

let $body = '',
    $datepickersContainer = '',
    $datepickerOverlay = '',
    containerBuilt = false,
    baseTemplate = '' + '<i class="air-datepicker--pointer"></i>' + '<div class="air-datepicker--navigation"></div>' + '<div class="air-datepicker--content"></div>';

function buildDatepickersContainer(id) {
    containerBuilt = true;
    $datepickersContainer = createElement({className: id, id});
    $body.appendChild($datepickersContainer);

    return $datepickersContainer;
}

class Datepicker {
    static defaults = defaults;
    static version = '3.2.0';
    static defaultContainerId = 'air-datepicker-global-container'
    $elId = '';
    viewIndexes = [consts.days, consts.months, consts.years];
    actions = document.createElement('div');
    switchPickerBtn = document.createElement('button');
    switchPickerBtnIcon = document.createElement('i');
    switchPickerBtnText = document.createElement('span');
    switchPickerBtnTextMessage = 'Ver semana';

    isWeekendPicker = false;

    weeklyIndex = 0;
    calendarRows = 5;

    weeklyDaySelected = {
        node: new Date(),
        index: 0,
        group: 'one',
        isToday: true,
        isSelected: false,
    };

    constructor(el, opts) {
        this.$elId = el;
        this.$el = getEl(el);

        if (!this.$el) return;

        this.$datepicker = createElement({className: 'air-datepicker'});
        this.opts = deepMerge({}, defaults, opts);
        this.$customContainer = this.opts.container ? getEl(this.opts.container) : false;
        this.$altField = getEl(this.opts.altField || false);

        if (!$body) $body = getEl('body');

        let {view, startDate} = this.opts;

        if (!startDate) this.opts.startDate = new Date();

        if (this.$el.nodeName === 'INPUT') this.elIsInput = true;

        this.inited = false;
        this.visible = false;

        this.viewDate = createDate(this.opts.startDate);
        this.focusDate = false;
        this.initialReadonly = this.$el.getAttribute('readonly');
        this.customHide = false;
        this.currentView = view;
        this.selectedDates = [];
        this.views = {};
        this.keys = [];
        this.rangeDateFrom = '';
        this.rangeDateTo = '';
        this.timepickerIsActive = false; // Need when autoClose and timepicker are both true
        this.treatAsInline = this.opts.inline || !this.elIsInput;

        this.weeklyDaySelected = {
            node: opts.startDate ?? new Date(),
            index: 0,
            group: 'one',
            isToday: true,
            isSelected: false,
        };

        if (!!this.opts.showSwitchOnTop) this._createSwitchBtn();

        this.init();

        if (!!this.opts.showSwitchOnTop) this.switchPickerBtn.click();
    }

    get shouldUpdateDOM() {
        return this.visible || this.treatAsInline;
    }

    get parsedViewDate() {
        return getParsedDate(this.viewDate);
    }

    //  Helpers
    // -------------------------------------------------

    get currentViewSingular() {
        return this.currentView.slice(0, -1);
    }

    get curDecade() {
        return getDecade(this.viewDate);
    }

    get viewIndex() {
        return this.viewIndexes.indexOf(this.currentView);
    }

    get isFinalView() {
        return this.currentView === consts.years;
    }

    get hasSelectedDates() {
        return this.selectedDates.length > 0;
    }

    get isMinViewReached() {
        return this.currentView === this.opts.minView || this.currentView === consts.days;
    }

    get $container() {
        return this.$customContainer || $datepickersContainer;
    }

    static withReminders = ({reminders = [], date, cellType, datepicker} = {}) => {
        const isDay = cellType === 'day';
        const _date = date.getDate();
        const _month = date.getMonth() + 1;
        const _year = date.getFullYear()

        const reminder = isDay && reminders.find((dateItem) => dateItem.date === _date && dateItem.month === _month && dateItem.year === _year,);

        switch (cellType) {
            case 'day':
                return {
                    html: `
                      <span>${_date}</span> 
                      <div class="datepicker-reminder">
                      <span class="${!!reminder ? (reminder.iconClass ? reminder.iconClass : 'icons dot-filled-before') : ''} ${!!reminder ? (reminder.colorClass ? reminder.colorClass : '') : ''}"></span>
                          </div> `, classes: reminder ? '-notification-cell-' : false
                }
            default:
                return {html: false, classes: false}
        }
    }

    static getLanguage = (locale = 'es') => {
        const spanish = {
            days: ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sabado'],
            daysShort: ['Dom', 'Lun', 'Mar', 'Mie', 'Jue', 'Vie', 'Sab'],
            daysMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
            months: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
            monthsShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
            today: 'Today',
            clear: 'Clear',
            dateFormat: 'dd/MM/yyyy',
            timeFormat: 'hh:mm aa',
            firstDay: 0
        };

        switch (locale) {
            case 'es':
                return spanish;
            default:
                return spanish;
        }
    }

    static replacer = (str, reg, data) => {
        return str.replace(reg, function (match, p1, p2, p3) {
            return p1 + data + p3;
        });
    }

    getWeeklyDayGroup = (index = 0) => {
        const _index = index + 1;

        const isOne = _index >= 1 && _index <= 7;
        const isTwo = _index >= 8 && _index <= 14;
        const isThree = _index >= 15 && _index <= 21;
        const isFour = _index >= 22 && _index <= 28;
        const isFive = _index >= 29 && _index <= 35;
        const isSix = _index >= 36 && _index <= 42;

        return {
            isOne,
            isTwo,
            isThree,
            isFour,
            isFive,
            isSix,
        }
    }

    _getDatePickerElements = () => {
        const [pointerNode, navigatorNode, contentNode, closeButtonNode] = Array.prototype.slice.call(this.$datepicker.childNodes);
        const [navigatorMainNode] = Array.prototype.slice.call(navigatorNode.childNodes);
        const [navigatorMainPrevNode, navigatorMainTitleNode, navigatorMainNextNode] = Array.prototype.slice.call(navigatorMainNode.childNodes);
        const [monthNode, yearNode] = Array.prototype.slice.call(navigatorMainTitleNode.childNodes);
        const [bodyNode] = Array.prototype.slice.call(contentNode.childNodes);
        const [namesNode, daysNode] = Array.prototype.slice.call(bodyNode.childNodes);
        const daysNodes = Array.prototype.slice.call(daysNode.childNodes);

        const cleanTitleTextRegex = /(,|\s)/gi;

        const monthText = monthNode.nodeValue.replace(cleanTitleTextRegex, '');
        const month = getMonthIndex(monthText);
        const year = Number(yearNode.innerText.replace(cleanTitleTextRegex, ''));

        return {
            pointerNode,
            navigatorNode,
            contentNode,
            closeButtonNode,
            navigatorMainNode,
            navigatorMainPrevNode,
            navigatorMainTitleNode,
            navigatorMainNextNode,
            monthNode,
            month,
            monthText,
            yearNode,
            year,
            bodyNode,
            namesNode,
            daysNode,
            daysNodes,
        };
    }

    _getDatePickerDayElements = ({$day, month, year, collection = []} = {}) => {
        const {startDate} = this.opts;

        if (!startDate) throw new Error('En las opciones, no se encontró la propiedad "startDate".', {cause: startDate});
        if (!(startDate instanceof Date)) throw new Error('En las opciones, la propiedad "startDate" deben ser de tipo "Date"', {cause: startDate});

        const startDateUTCDay = startDate.getUTCDay();
        const startDateUTCDate = startDate.getUTCDate();
        const startDateUTCYear = startDate.getUTCFullYear();

        const {node} = $day;

        const dayTextNode = node.querySelector('span');
        const dayText = dayTextNode.innerText.trim();
        const day = Number(dayText);

        const date = new Date(year, month, day);

        const cause = {$day, date};

        if (!date) throw new Error('La propiedad "date" de los dias (celdas) deben ser de tipo "Date"', {cause});
        if (!(date instanceof Date)) throw new Error('La propiedad "date" de los dias (celdas) deben ser de tipo "Date"', {cause});

        const dayUTCDay = date.getUTCDay();
        const dayUTCDate = date.getUTCDate();
        const dayUTCYear = date.getUTCFullYear();

        const sameDay = dayUTCDay === startDateUTCDay;
        const sameDate = dayUTCDate === startDateUTCDate;
        const sameYear = dayUTCYear === startDateUTCYear;

        let isToday = false;
        let isSelected = false;

        if (sameDay && sameDate && sameYear) isToday = true;
        if (node.classList.contains('-selected-')) isSelected = true;

        return {...$day, date, day, isToday, isSelected};
    }

    _getWeeklyRange = (customIndex) => Object.values(this._generateWeeklyGroups())[customIndex || this.weeklyIndex] ?? Object.values(this._generateWeeklyGroups())[customIndex ?? 0];

    getDayWeekGroupNameByIndex = (index = 0) => {
        const group = this.getWeeklyDayGroup(index);

        if (group.isOne) return 'one';
        else if (group.isTwo) return 'two';
        else if (group.isThree) return 'three';
        else if (group.isFour) return 'four';
        else if (group.isFive) return 'five';
        else if (group.isSix) return 'six';
        else return 'notFound';
    }

    _generateWeeklyGroupNameByIndex = (index = 0) => {
        switch (index) {
            case 0:
                return 'one';
            case 1:
                return 'two';
            case 2:
                return 'three';
            case 3:
                return 'four';
            case 4:
                return 'five';
            case 5:
                return 'six';
            case 6:
                return 'seven';
            default:
                return undefined;
        }
    }

    _generateWeeklyGroupIndexByName = (groupName = '') => {
        switch (groupName) {
            case 'one':
                return 0;
            case 'two':
                return 1;
            case 'three':
                return 2;
            case 'four':
                return 3;
            case 'five':
                return 4;
            case 'six':
                return 5;
            case 'seven':
                return 6;
            default:
                return undefined;
        }
    }

    _generateWeeklyGroups = () => {
        const {daysNodes = [], year, month} = this._getDatePickerElements();

        const daysNodesFormatted = daysNodes.map(($day, dayIndex = 0) => {
            const isToday = false;
            const isSelected = false;
            const enable = true;

            return {
                node: $day,
                index: dayIndex,
                group: this.getDayWeekGroupNameByIndex(dayIndex),
                isToday,
                isSelected,
                enable,
            };
        });

        const groups = daysNodesFormatted
            .reduce((acc = {}, $day, $dayIndex) => {
                const $dayUpdated = this._getDatePickerDayElements({
                    $day,
                    month,
                    year,
                    collection: daysNodesFormatted,
                });

                switch ($dayUpdated.group) {
                    case 'one':
                        return {...acc, one: [...(acc.one || []), $dayUpdated]};
                    case 'two':
                        return {...acc, two: [...(acc.two || []), $dayUpdated]};
                    case 'three':
                        return {...acc, three: [...(acc.three || []), $dayUpdated]};
                    case 'four':
                        return {...acc, four: [...(acc.four || []), $dayUpdated]};
                    case 'five':
                        return {...acc, five: [...(acc.five || []), $dayUpdated]};
                    case 'six':
                        return {...acc, six: [...(acc.six || []), $dayUpdated]};
                    case 'seven':
                        return {...acc, seven: [...(acc.seven || []), $dayUpdated]};
                    default:
                        return acc;
                }
            }, {});

        const allDates = Object.values(groups).reduce((acc, group) => [...acc, ...group], []);

        const findDateByDate = ($day, match = 1) => $day.date.getUTCDate() === match;

        const daysOnes = allDates.filter(($day) => findDateByDate($day));

        const startDate = daysOnes[0];
        const endDate = daysOnes[1];

        return Object.entries(groups).reduce((acc = {}, [groupName, group]) => {
            const groupWithMonthsUpdated = group.map(($day) => {
                const _date = $day.date.getUTCDate();
                const _year = $day.date.getUTCFullYear();

                if (!!startDate && $day.index <= startDate.index && $day.day > startDate.day) {
                    const _month = $day.date.getUTCMonth() - 1;

                    return {
                        ...$day,
                        enable: false,
                        date: new Date(_year, _month, _date),
                    };
                } else if (!!endDate && $day.index >= endDate.index && $day.day >= endDate.day) {
                    const _month = $day.date.getUTCMonth() + 1;

                    return {
                        ...$day,
                        enable: false,
                        date: new Date(_year, _month, _date),
                    };
                }

                return $day;
            });

            return {
                ...acc,
                [groupName]: groupWithMonthsUpdated,
            };
        }, {});
    }

    _generateWeeklyGroup = ({date = this.opts.startDate || new Date(), findSelected = false} = {}) => {
        const _startDate = date.getUTCDate();
        const _startMonth = date.getUTCMonth();
        const _startYear = date.getUTCFullYear();

        const groups = this._generateWeeklyGroups();

        let groupIndex = undefined;
        let cellMatch = undefined;

        const group = Object.values(groups).find((group = [], _groupIndex = 0) => {
            const match = group.find((cellData = {}) => {
                const {date = new Date(), node} = cellData;

                const _date = date.getUTCDate();
                const _month = date.getUTCMonth();
                const _year = date.getUTCFullYear();

                let isMatch = _date === _startDate && _month === _startMonth && _year && _startYear;

                if (isMatch) cellMatch = cellData;

                if (findSelected) {
                    const hasSelectedClass = !!node.classList.contains(`${consts.nameSpace}-selected`);

                    if (hasSelectedClass) {
                        isMatch = true;
                        cellMatch = cellData;
                    }
                }

                return isMatch;
            });

            groupIndex = _groupIndex;

            return !!match;
        });

        if (!!group && group.length === 0) return this._generateWeeklyGroup();

        return {group, groupIndex, cellMatch};
    }

    _generateWeekly = ({date = this.opts.startDate || new Date()} = {}) => {
        const {group, groupIndex, cellMatch} = this._generateWeeklyGroup({date});

        if (group.length !== 7) throw new Error('Ocurrió algo al momento de generar los datos de la semana actual.');

        this.weeklyIndex = groupIndex;

        this.weeklyPicker = new WeeklyViewV2({
            items: group,
            reminders: this.opts.reminders || [],
            onClickCell: (event, cellData) => {
                this.selectDate(cellData.date);

                const itemsWithSelection = this._generateWeeklyGroup({date: cellData.date});

                this.weeklyPicker.update(itemsWithSelection.group, true);
            },
            prevWeek: ({target}) => {
                this.weeklyIndex -= 1;

                if (this.weeklyIndex === -1) {
                    this.weeklyIndex = this.calendarRows;
                    this.prev();
                }

                const prevItems = this._getWeeklyRange();

                this.weeklyPicker.update(prevItems, true);
            },
            nextWeek: ({target}) => {
                this.weeklyIndex += 1;

                if (this.weeklyIndex > this.calendarRows) {
                    this.weeklyIndex = 0;
                    this.next();
                }

                const prevItems = this._getWeeklyRange();

                this.weeklyPicker.update(prevItems, true);
            },
        });
    }

    init = () => {
        let container;

        let {
            opts, treatAsInline, opts: {
                inline, isMobile, selectedDates, keyboardNav, onlyTimepicker
            }
        } = this;

        if (!containerBuilt && !inline && this.elIsInput) {
            container = buildDatepickersContainer(Datepicker.defaultContainerId);
        }

        if (isMobile && !$datepickerOverlay && !treatAsInline) {
            this._createMobileOverlay();
        }

        this._handleLocale();
        this._bindSubEvents();
        this._createMinMaxDates();
        this._limitViewDateByMaxMinDates();


        if (this.elIsInput) {
            if (!inline) {
                this._bindEvents();
            }

            if (keyboardNav && !onlyTimepicker) {
                this.keyboardNav = new DatepickerKeyboard({dp: this, opts});
            }
        }

        if (selectedDates) {
            this.selectDate(selectedDates, {silent: true});
        }

        if (this.opts.visible && !treatAsInline) {
            this.show();
        }

        if (isMobile && !treatAsInline) {
            this.$el.setAttribute('readonly', true);
        }

        if (treatAsInline) {
            this._createComponents();
        }

        //  if (!!container) this._closeButton({container});
    }

    _createSwitchBtn = () => {
        this.switchPickerBtnTextMessage = this.isWeekendPicker ? 'Ver mes' : 'Ver semana';
        this.switchPickerBtnText.innerText = this.switchPickerBtnTextMessage;

        this.$el.classList.add('style-container-picker', 'd-flex', 'f-column');
        this.actions.classList.add('action-style', 'd-flex', 'j-content-end', 'a-items-center');
        this.switchPickerBtn.classList.add(
            'b-none',
            'typography-link',
            'd-flex',
            'j-content-end',
            'a-items-center',
            'm-bottom-xs',
            'm-left-l',
            'p-top-reset',
            'p-right-reset',
            'p-left-reset',
            'p-bottom-s',
            'b-radius-xxs',
            'bg-color-none'
        );

        this.switchPickerBtnIcon.classList.add('icons', 'c-interaction-low', 'month-stroke-before', 'icons-2xl', 'm-right-xs');
        this.switchPickerBtn.classList.add('switch-btn')

        this.switchPickerBtn.appendChild(this.switchPickerBtnIcon);
        this.switchPickerBtn.appendChild(this.switchPickerBtnText);
        this.actions.appendChild(this.switchPickerBtn);

        this.$el.appendChild(this.actions);

        this.switchPickerBtn.addEventListener('click', ({target}) => {
            this.$el.innerHTML = '';

            this.isWeekendPicker = !this.isWeekendPicker;

            this.switchPickerBtnText.innerText = this.isWeekendPicker ? 'Ver mes' : 'Ver semana';

            this.$el.appendChild(this.actions);


            if (this.isWeekendPicker) {
                this._generateWeekly();

                this.switchPickerBtnIcon.classList.remove('icons', 'c-interaction-low', 'week-stroke-before', 'icons-2xl', 'm-right-xs');
                this.switchPickerBtnIcon.classList.add('icons', 'c-interaction-low', 'month-stroke-before', 'icons-2xl', 'm-right-xs');

                this.$el.appendChild(this.weeklyPicker.$el);
            } else {
                this.switchPickerBtnIcon.classList.remove('icons', 'c-interaction-low', 'month-stroke-before', 'icons-2xl', 'm-right-xs');
                this.switchPickerBtnIcon.classList.add('icons', 'c-interaction-low', 'week-stroke-before', 'icons-2xl', 'm-right-xs');
                this.$el.appendChild(this.$datepicker);
            }
        });
    };

    _createMobileOverlay = () => {
        $datepickerOverlay = createElement({className: 'air-datepicker-overlay'});
        $datepickersContainer.appendChild($datepickerOverlay);
    }

    _closeButton = ({container}) => {
        const {opts: {showCLoseButton = false}} = this;
        const closeButtonOverlay = document.createElement('button');

        closeButtonOverlay.classList.add('position-relative', 'icons', 'c-black', 'x-block-before', 'icons-2xl', `close-btn${showCLoseButton ? '-show' : '-hidden'}`);

        container.appendChild(closeButtonOverlay);

        closeButtonOverlay.addEventListener('click', (e) => {
            $datepickerOverlay.click();
        })
    }

    _createComponents = () => {
        let {
            opts, treatAsInline, opts: {
                inline,
                buttons,
                timepicker,
                position,
                classes,
                onlyTimepicker,
                isMobile,
            }
        } = this;
        let dp = this;

        this._buildBaseHtml();

        if (this.elIsInput) {
            if (!inline) {
                this._setPositionClasses(position);
            }
        }

        if (inline || !this.elIsInput) {
            this.$datepicker.classList.add('-inline-');
        }

        if (classes) {
            this.$datepicker.classList.add(...classes.split(' '));
        }

        if (onlyTimepicker) {
            this.$datepicker.classList.add('-only-timepicker-');
        }

        if (isMobile && !treatAsInline) {
            this._addMobileAttributes();
        }

        this.views[this.currentView] = new DatepickerBody({
            dp, type: this.currentView, opts
        });

        this.nav = new DatepickerNav({dp, opts});

        if (timepicker) {
            this._addTimepicker();
        }

        if (buttons) {
            this._addButtons();
        }

        this.$content.appendChild(this.views[this.currentView].$el);
        this.$nav.appendChild(this.nav.$el);
    }

    _destroyComponents = () => {
        for (let view in this.views) {
            this.views[view].destroy();
        }
        this.views = {};
        this.nav.destroy();
        if (this.timepicker) {
            this.timepicker.destroy();
        }
    }

    _addMobileAttributes = () => {
        $datepickerOverlay.addEventListener('click', this._onClickOverlay);

        this.$datepicker.classList.add('-is-mobile-');
        this.$el.setAttribute('readonly', true);
    }

    _removeMobileAttributes = () => {
        $datepickerOverlay.removeEventListener('click', this._onClickOverlay);

        this.$datepicker.classList.remove('-is-mobile-');

        if (!this.initialReadonly && this.initialReadonly !== '') {
            this.$el.removeAttribute('readonly');
        }
    }

    _createMinMaxDates = () => {
        let {minDate, maxDate} = this.opts;

        this.minDate = minDate ? createDate(minDate) : false;
        this.maxDate = maxDate ? createDate(maxDate) : false;
    }

    _addTimepicker = () => {
        this.$timepicker = createElement({className: 'air-datepicker--time'});
        this.$datepicker.appendChild(this.$timepicker);
        this.timepicker = new DatepickerTime({dp: this, opts: this.opts});
        this.$timepicker.appendChild(this.timepicker.$el);
    }

    _addButtons = () => {
        this.$buttons = createElement({className: 'air-datepicker--buttons'});
        this.$datepicker.appendChild(this.$buttons);
        this.buttons = new DatepickerButtons({dp: this, opts: this.opts});
        this.$buttons.appendChild(this.buttons.$el);
    }

    _bindSubEvents = () => {
        this.on(consts.eventChangeSelectedDate, this._onChangeSelectedDate);
        this.on(consts.eventChangeFocusDate, this._onChangeFocusedDate);
        this.on(consts.eventChangeTime, this._onChangeTime);
    }

    _buildBaseHtml = () => {
        let {inline} = this.opts;

        if (this.elIsInput) {
            if (!inline) {
                this.$container.appendChild(this.$datepicker);
            } else {
                insertAfter(this.$datepicker, this.$el);
            }
        } else {
            this.$el.appendChild(this.$datepicker);
        }

        this.$datepicker.innerHTML = baseTemplate;


        this.$content = getEl('.air-datepicker--content', this.$datepicker);
        this.$pointer = getEl('.air-datepicker--pointer', this.$datepicker);
        this.$nav = getEl('.air-datepicker--navigation', this.$datepicker);

        this._closeButton({container: this.$datepicker});
        //this._ShowWeek({container: this.$datepicker});
    }

    _handleLocale = () => {
        let {locale, dateFormat, firstDay, timepicker, onlyTimepicker, timeFormat, dateTimeSeparator} = this.opts;
        this.locale = deepCopy(locale);

        if (dateFormat) {
            this.locale.dateFormat = dateFormat;
        }
        // Allow to remove time from formatted string
        // e.g. if user wants to display mm:hh yyyy MMMM (time first) instead of hardcoded order - 'date time`
        if (timeFormat !== undefined && timeFormat !== '') {
            this.locale.timeFormat = timeFormat;
        }

        let {timeFormat: timeFormatValidated} = this.locale;

        if (firstDay !== '') {
            this.locale.firstDay = firstDay;
        }

        if (timepicker && typeof dateFormat !== 'function') {
            let separator = timeFormatValidated ? dateTimeSeparator : '';
            this.locale.dateFormat = [this.locale.dateFormat, (timeFormatValidated ? timeFormatValidated : '')].join(separator);
        }

        if (onlyTimepicker) {
            this.locale.dateFormat = this.locale.timeFormat;
        }
    }

    _setPositionClasses = (pos) => {
        if (typeof pos === 'function') {
            this.$datepicker.classList.add('-custom-position-');

            return;
        }

        pos = pos.split(' ');
        let main = pos[0], sec = pos[1], classes = `air-datepicker -${main}-${sec}- -from-${main}-`;

        this.$datepicker.classList.add(...classes.split(' '));
    }

    _bindEvents = () => {
        this.$el.addEventListener(this.opts.showEvent, this._onFocus);
        this.$el.addEventListener('blur', this._onBlur);
        this.$datepicker.addEventListener('mousedown', this._onMouseDown);
        this.$datepicker.addEventListener('mouseup', this._onMouseUp);
        window.addEventListener('resize', this._onResize);
    }

    _limitViewDateByMaxMinDates = () => {
        let {viewDate, minDate, maxDate} = this;

        if (maxDate && isDateBigger(viewDate, maxDate)) {
            this.setViewDate(maxDate);
        }
        if (minDate && isDateSmaller(viewDate, minDate)) {
            this.setViewDate(minDate);
        }
    }

    formatDate = (date = this.viewDate, string) => {
        date = createDate(date);

        if (!(date instanceof Date)) return;

        let result = string, locale = this.locale, parsedDate = getParsedDate(date), decade = getDecade(date),
            replacer = Datepicker.replacer, dayPeriod = 'am';

        if (this.opts.timepicker && this.timepicker) {
            dayPeriod = this.timepicker.getDayPeriod(date).dayPeriod;
        }

        let formats = {
            // Time in ms
            T: date.getTime(),

            // Minutes
            m: parsedDate.minutes,
            mm: parsedDate.fullMinutes,

            // Hours
            h: parsedDate.hours12,
            hh: parsedDate.fullHours12,
            H: parsedDate.hours,
            HH: parsedDate.fullHours,

            // Day period
            aa: dayPeriod,
            AA: dayPeriod.toUpperCase(),

            // Day of week
            E: locale.daysShort[parsedDate.day],
            EEEE: locale.days[parsedDate.day],

            // Date of month
            d: parsedDate.date,
            dd: parsedDate.fullDate,

            // Months
            M: parsedDate.month + 1,
            MM: parsedDate.fullMonth,
            MMM: locale.monthsShort[parsedDate.month],
            MMMM: locale.months[parsedDate.month],

            // Years
            yy: parsedDate.year.toString().slice(-2),
            yyyy: parsedDate.year,
            yyyy1: decade[0],
            yyyy2: decade[1]
        };


        for (let [format, data] of Object.entries(formats)) {
            result = replacer(result, getWordBoundaryRegExp(format), data);
        }

        return result;
    }

    /**
     * Changes month, year, decade to next period
     */
    next = () => {
        let {year, month} = this.parsedViewDate;

        switch (this.currentView) {
            case consts.days:
                this.setViewDate(new Date(year, month + 1, 1));
                break;
            case consts.months:
                this.setViewDate(new Date(year + 1, month, 1));
                break;
            case consts.years:
                this.setViewDate(new Date(year + 10, 0, 1));
                break;
        }
    }

    /**
     * Changes month, year, decade to prev period
     */
    prev = () => {
        let {year, month} = this.parsedViewDate;

        switch (this.currentView) {
            case consts.days:
                this.setViewDate(new Date(year, month - 1, 1));
                break;
            case consts.months:
                this.setViewDate(new Date(year - 1, month, 1));
                break;
            case consts.years:
                this.setViewDate(new Date(year - 10, 0, 1));
                break;
        }
    }

    down = (date) => {
        this._handleUpDownActions(date, 'down');
    }

    up = (date) => {
        this._handleUpDownActions(date, 'up');
    }

    /**
     * Selects date, if array is passed then selects dates one by one
     * @param {Date|Boolean} date
     * @param {object} [params] - extra parameters
     * @param {boolean} [params.updateTime] - should update timepicker's time from passed date
     * @param {boolean} [params.silent] - if true, then onChange event wont be triggered
     * @return {Promise<unknown>} - returns promise, since input value updates asynchronously, after promise resolves, we need a promise tobe able to get current input value
     * @example selectDate(new Date()).then(() => {console.log(dp.$el.value)})
     */
    selectDate = (date, params = {}) => {
        let {currentView, parsedViewDate, selectedDates} = this;
        let {updateTime} = params;
        let {
            moveToOtherMonthsOnSelect, moveToOtherYearsOnSelect, multipleDates, range, autoClose
        } = this.opts;
        let selectedDaysLen = selectedDates.length;
        let newViewDate;

        if (Array.isArray(date)) {
            date.forEach((d) => {
                this.selectDate(d, params);
            });

            return new Promise((resolve) => {
                setTimeout(resolve);
            });
        }

        date = createDate(date);

        if (!(date instanceof Date)) return undefined;

        // Checks if selected date is out of current month or decade
        // If so, change `viewDate`
        if (currentView === consts.days) {
            if (date.getMonth() !== parsedViewDate.month && moveToOtherMonthsOnSelect) {
                newViewDate = new Date(date.getFullYear(), date.getMonth(), 1);
            }
        }

        if (currentView === consts.years) {
            if (date.getFullYear() !== parsedViewDate.year && moveToOtherYearsOnSelect) {
                newViewDate = new Date(date.getFullYear(), 0, 1);
            }
        }

        if (newViewDate) {
            this.setViewDate(newViewDate);
        }

        if (multipleDates && !range) {
            if (selectedDaysLen === multipleDates) return undefined;
            if (!this._checkIfDateIsSelected(date)) {
                selectedDates.push(date);
            }
        } else if (range) {
            switch (selectedDaysLen) {
                case 1:
                    selectedDates.push(date);
                    // Need to define this manually if call selectDate programmatically
                    if (!this.rangeDateTo) {
                        this.rangeDateTo = date;
                    }
                    // Swap dates if they were selected via dp.selectDate() and second date was smaller then first
                    if (isDateBigger(this.rangeDateFrom, this.rangeDateTo)) {
                        this.rangeDateTo = this.rangeDateFrom;
                        this.rangeDateFrom = date;
                    }
                    this.selectedDates = [this.rangeDateFrom, this.rangeDateTo];
                    break;
                case 2:
                    this.selectedDates = [date];
                    this.rangeDateFrom = date;
                    this.rangeDateTo = '';
                    break;
                default:
                    this.selectedDates = [date];
                    this.rangeDateFrom = date;
            }
        } else {
            this.selectedDates = [date];
        }

        this.trigger(consts.eventChangeSelectedDate, {
            action: consts.actionSelectDate,
            silent: params?.silent,
            date,
            updateTime,
        });

        this._updateLastSelectedDate(date);

        if (autoClose && !this.timepickerIsActive && this.visible) {
            if (!multipleDates && !range) {
                this.hide();
            } else if (range && selectedDaysLen === 1) {
                this.hide();
            }
        }

        return new Promise((resolve) => {
            setTimeout(resolve);
        });
    }

    unselectDate = (date) => {
        let selected = this.selectedDates, _this = this;

        date = createDate(date);

        if (!(date instanceof Date)) return;

        return selected.some((curDate, i) => {
            if (isSameDate(curDate, date)) {
                selected.splice(i, 1);

                if (!_this.selectedDates.length) {
                    _this.rangeDateFrom = '';
                    _this.rangeDateTo = '';
                    _this._updateLastSelectedDate(false);
                } else {
                    _this._updateLastSelectedDate(_this.selectedDates[_this.selectedDates.length - 1]);
                }

                this.trigger(consts.eventChangeSelectedDate, {action: consts.actionUnselectDate, date});

                return true;
            }
        });
    }

    replaceDate = (selectedDate, newDate) => {
        let date = this.selectedDates.find((d) => {
            return isSameDate(d, selectedDate, this.currentView);
        });
        let index = this.selectedDates.indexOf(date);

        if (index < 0) return;

        // Add check if same date exists, if so don't trigger change events
        if (isSameDate(this.selectedDates[index], newDate, this.currentView)) {
            return;
        }

        this.selectedDates[index] = newDate;

        this.trigger(consts.eventChangeSelectedDate, {
            action: consts.actionSelectDate, date: newDate, updateTime: true
        });

        this._updateLastSelectedDate(newDate);
    }

    /**
     * Clears all selected dates
     * @param {boolean} params.silent  - trigger or not user onSelect event
     */
    clear = (params = {}) => {
        this.selectedDates = [];
        this.rangeDateFrom = false;
        this.rangeDateTo = false;

        this.trigger(consts.eventChangeSelectedDate, {action: consts.actionUnselectDate, silent: params.silent});

        return new Promise((resolve) => {
            setTimeout(resolve);
        });
    }

    show = () => {
        let {onShow, isMobile} = this.opts;
        this._cancelScheduledCall();

        if (!this.visible && !this.hideAnimation) {
            this._createComponents();
        }

        this.setPosition(this.opts.position);

        this.$datepicker.classList.add('-active-');
        this.visible = true;

        if (onShow) {
            this._scheduleCallAfterTransition(onShow);
        }

        if (isMobile) {
            this._showMobileOverlay();
        }
    }

    hide = () => {
        let {onHide, isMobile} = this.opts;
        let hasTransition = this._hasTransition();

        this.visible = false;
        this.hideAnimation = true;

        this.$datepicker.classList.remove('-active-');

        if (this.customHide) {
            this.customHide();
        }

        if (this.elIsInput) {
            this.$el.blur();
        }

        this._scheduleCallAfterTransition((isAnimationCompleted) => {
            if (!this.customHide && ((isAnimationCompleted && hasTransition) || (!isAnimationCompleted && !hasTransition))) {
                this._finishHide();
            }
            onHide && onHide(isAnimationCompleted);
        });

        if (isMobile) {
            $datepickerOverlay.classList.remove('-active-');
        }
    }

    _finishHide = () => {
        this.hideAnimation = false;
        this._destroyComponents();
        this.$container.removeChild(this.$datepicker);
    }

    setPosition = (position, isViewChange = false) => {
        position = position || this.opts.position;

        if (typeof position === 'function') {
            this.customHide = position({
                $datepicker: this.$datepicker,
                $target: this.$el,
                $pointer: this.$pointer,
                isViewChange,
                done: this._finishHide
            });
            return;
        }

        let {isMobile} = this.opts;

        let vpDims = this.$el.getBoundingClientRect(), dims = this.$el.getBoundingClientRect(),
            $dpOffset = this.$datepicker.offsetParent, $elOffset = this.$el.offsetParent,
            selfDims = this.$datepicker.getBoundingClientRect(), pos = position.split(' '), top, left,
            scrollTop = window.scrollY, scrollLeft = window.scrollX, offset = this.opts.offset, main = pos[0],
            secondary = pos[1];

        if (isMobile) {
            this.$datepicker.style.cssText = 'left: 50%; top: 50%';
            return;
        }

        // If datepicker's container is the same with target element
        if ($dpOffset === $elOffset && $dpOffset !== document.body) {
            dims = {
                top: this.$el.offsetTop, left: this.$el.offsetLeft, width: vpDims.width, height: this.$el.offsetHeight
            };

            scrollTop = 0;
            scrollLeft = 0;
        }

        // If dp container is different from target offset parent
        // and dp offset parent has position not static (default case)
        if ($dpOffset !== $elOffset && $dpOffset !== document.body) {
            let dpOffsetDims = $dpOffset.getBoundingClientRect();

            dims = {
                top: vpDims.top - dpOffsetDims.top,
                left: vpDims.left - dpOffsetDims.left,
                width: vpDims.width,
                height: vpDims.height
            };

            scrollTop = 0;
            scrollLeft = 0;
        }

        switch (main) {
            case 'top':
                top = dims.top - selfDims.height - offset;
                break;
            case 'right':
                left = dims.left + dims.width + offset;
                break;
            case 'bottom':
                top = dims.top + dims.height + offset;
                break;
            case 'left':
                left = dims.left - selfDims.width - offset;
                break;
        }

        switch (secondary) {
            case 'top':
                top = dims.top;
                break;
            case 'right':
                left = dims.left + dims.width - selfDims.width;
                break;
            case 'bottom':
                top = dims.top + dims.height - selfDims.height;
                break;
            case 'left':
                left = dims.left;
                break;
            case 'center':
                if (/left|right/.test(main)) {
                    top = dims.top + dims.height / 2 - selfDims.height / 2;
                } else {
                    left = dims.left + dims.width / 2 - selfDims.width / 2;
                }
        }

        this.$datepicker.style.cssText = `left: ${left + scrollLeft}px; top: ${top + scrollTop}px`;
    }

    _setInputValue = () => {
        let {opts, $altField, locale: {dateFormat}} = this, {altFieldDateFormat, altField} = opts;

        if (altField && $altField) {
            $altField.value = this._getInputValue(altFieldDateFormat);
        }

        this.$el.value = this._getInputValue(dateFormat);
    }

    _getInputValue = (dateFormat) => {
        let {selectedDates, opts} = this, {multipleDates, multipleDatesSeparator} = opts;

        if (!selectedDates.length) return '';

        let formatIsFunction = typeof dateFormat === 'function';

        let value = formatIsFunction ? dateFormat(multipleDates ? selectedDates : selectedDates[0]) : selectedDates.map((date) => {
            return this.formatDate(date, dateFormat);
        });

        value = formatIsFunction ? value : value.join(multipleDatesSeparator);

        return value;
    }

    _triggerOnSelect = () => {
        let dates = [], formattedDates = [], datepicker = this, {
            selectedDates, locale, opts: {onSelect, multipleDates, range}
        } = datepicker, isMultiple = multipleDates || range, formatIsFunction = typeof locale.dateFormat === 'function';

        if (selectedDates.length) {
            dates = selectedDates.map(copyDate);
            formattedDates = formatIsFunction ? multipleDates ? locale.dateFormat(dates) : dates.map(date => locale.dateFormat(date)) : dates.map(date => this.formatDate(date, locale.dateFormat));
        }

        onSelect({
            date: isMultiple ? dates : dates[0],
            formattedDate: isMultiple ? formattedDates : formattedDates[0],
            datepicker
        });
    }

    /**
     * Checks if date is already selected, returns selected date if finds one
     * Returns selected date, need for timepicker
     * @param {Date} date
     * @param {String} cellType - days, months, years
     * @return {boolean|Date}
     * @private
     */
    /* Comprobando si la fecha ya está seleccionada. */
    _checkIfDateIsSelected = (date, cellType = consts.days) => {
        let alreadySelectedDate = false;

        this.selectedDates.some((selectedDate) => {
            let same = isSameDate(date, selectedDate, cellType);
            alreadySelectedDate = same && selectedDate;
            return same;
        });

        return alreadySelectedDate;
    }

    _handleAlreadySelectedDates = (alreadySelectedDate, newSelectedDate) => {
        let {range, toggleSelected} = this.opts;
        if (range) {
            if (!toggleSelected) {
                // Add possibility to select same date when range is true
                if (this.selectedDates.length !== 2) {
                    this.selectDate(newSelectedDate);
                }
            } else {
                this.unselectDate(newSelectedDate);
            }
        } else if (toggleSelected) {
            this.unselectDate(newSelectedDate);
        }

        // Change last selected date to be able to change time when clicking on this cell
        if (!toggleSelected) {
            this._updateLastSelectedDate(alreadySelectedDate);
        }
    }

    _handleUpDownActions = (date, dir) => {
        let maxViewIndex = 2, minViewIndex = 0;

        date = createDate(date || this.focusDate || this.viewDate);

        if (!(date instanceof Date)) return;

        let nextView = dir === 'up' ? this.viewIndex + 1 : this.viewIndex - 1;
        if (nextView > maxViewIndex) nextView = maxViewIndex;
        if (nextView < minViewIndex) nextView = minViewIndex;

        this.setViewDate(new Date(date.getFullYear(), date.getMonth(), 1));
        this.setCurrentView(this.viewIndexes[nextView]);
    }

    _handleRangeOnFocus = () => {
        if (this.selectedDates.length === 1) {
            let selectedDate = this.selectedDates[0];
            if (isDateBigger(selectedDate, this.focusDate)) {
                this.rangeDateTo = this.selectedDates[0];
                this.rangeDateFrom = this.focusDate;
            } else {
                this.rangeDateTo = this.focusDate;
                this.rangeDateFrom = this.selectedDates[0];
            }
        }
    }

    _scheduleCallAfterTransition = (cb) => {
        this._cancelScheduledCall();

        cb && cb(false);

        this._onTransitionEnd = () => {
            cb && cb(true);
        };

        this.$datepicker.addEventListener('transitionend', this._onTransitionEnd, {once: true});
    }

    _cancelScheduledCall = () => {
        this.$datepicker.removeEventListener('transitionend', this._onTransitionEnd);
    }

    /**
     * Sets new view date of datepicker
     * @param {Date} date
     */
    setViewDate = (date) => {
        date = createDate(date);

        if (!(date instanceof Date)) return;

        if (isSameDate(date, this.viewDate)) return;
        let oldViewDate = this.viewDate;
        this.viewDate = date;
        let {onChangeViewDate} = this.opts;

        if (onChangeViewDate) {
            let {month, year} = this.parsedViewDate;
            onChangeViewDate({
                month, year, decade: this.curDecade
            });
        }

        this.trigger(consts.eventChangeViewDate, date, oldViewDate);
    }

    /**
     * Sets new focusDate
     * @param {Date} date
     * @param {Object} [params]
     * @param {Boolean} params.viewDateTransition
     */
    setFocusDate = (date, params = {}) => {
        if (date) {
            date = createDate(date);

            if (!(date instanceof Date)) return;
        }

        this.focusDate = date;

        if (this.opts.range && date) {
            this._handleRangeOnFocus();
        }

        this.trigger(consts.eventChangeFocusDate, date, params);
    }

    /**
     * Sets new datepicker view
     * @param {ViewType} view
     */
    setCurrentView = (view) => {
        if (!this.viewIndexes.includes(view)) return;

        this.currentView = view;

        if (this.elIsInput && this.visible) {
            this.setPosition(undefined, true);
        }

        // Trigger inner event before new view is inited, to avoid multiple render calls in datepicker body
        this.trigger(consts.eventChangeCurrentView, view);

        if (!this.views[view]) {
            let newView = this.views[view] = new DatepickerBody({
                dp: this, opts: this.opts, type: view
            });

            if (this.shouldUpdateDOM) {
                this.$content.appendChild(newView.$el);
            }
        }

        // Trigger user event after, to be able to use datepicker api on rendered view
        if (this.opts.onChangeView) {
            this.opts.onChangeView(view);
        }
    }

    /**
     * Updates lastSelectedDate param and triggers corresponding event
     * @param {Date|Boolean} date - date or empty
     */
    _updateLastSelectedDate = (date) => {
        this.lastSelectedDate = date;
        this.trigger(consts.eventChangeLastSelectedDate, date);
    }

    /**
     * Finds cell HTML element
     * @param {DateLike} cellDate
     * @param {CellType} cellType
     * @return {HTMLElement | null}
     */
    getCell = (cellDate, cellType = consts.day) => {
        cellDate = createDate(cellDate);

        if (!(cellDate instanceof Date)) return;

        let {year, month, date} = getParsedDate(cellDate);

        let yearQuery = `[data-year="${year}"]`, monthQuery = `[data-month="${month}"]`,
            dayQuery = `[data-date="${date}"]`;

        let resultQuery = {
            [consts.day]: `${yearQuery}${monthQuery}${dayQuery}`,
            [consts.month]: `${yearQuery}${monthQuery}`,
            [consts.year]: `${yearQuery}`,
        };

        return this.views[this.currentView].$el.querySelector(resultQuery[cellType]);
    }

    destroy = () => {
        let {showEvent, isMobile} = this.opts;

        let parent = this.$datepicker.parentNode;
        if (parent) {
            parent.removeChild(this.$datepicker);
        }

        this.$el.removeEventListener(showEvent, this._onFocus);
        this.$el.removeEventListener('blur', this._onBlur);
        window.removeEventListener('resize', this._onResize);
        if (isMobile) {
            this._removeMobileAttributes();
        }

        if (this.keyboardNav) {
            this.keyboardNav.destroy();
        }

        this.views = null;
        this.nav = null;

        this.$datepicker = null;
        this.opts = null;
        this.$customContainer = null;

        this.viewDate = null;
        this.focusDate = null;
        this.selectedDates = null;
        this.rangeDateFrom = null;
        this.rangeDateTo = null;
    }

    update = (newOpts) => {
        let prevOpts = deepMerge({}, this.opts);
        deepMerge(this.opts, newOpts);

        let {timepicker, buttons, range, selectedDates, isMobile} = this.opts;
        let shouldUpdateDOM = this.visible || this.treatAsInline;

        this._createMinMaxDates();
        this._limitViewDateByMaxMinDates();
        this._handleLocale();

        if (!prevOpts.selectedDates && selectedDates) {
            this.selectDate(selectedDates);
        }

        if (newOpts.view) {
            this.setCurrentView(newOpts.view);
        }

        this._setInputValue();

        if (prevOpts.range && !range) {
            this.rangeDateTo = false;
            this.rangeDateFrom = false;
        } else if (!prevOpts.range && range) {
            if (this.selectedDates.length) {
                this.rangeDateFrom = this.selectedDates[0];
                this.rangeDateTo = this.selectedDates[1];
            }
        }

        if (prevOpts.timepicker && !timepicker) {
            shouldUpdateDOM && this.timepicker.destroy();
            this.timepicker = false;
            this.$timepicker.parentNode.removeChild(this.$timepicker);
        } else if (!prevOpts.timepicker && timepicker) {
            this._addTimepicker();
        }

        if (!prevOpts.buttons && buttons) {
            this._addButtons();
        } else if (prevOpts.buttons && !buttons) {
            this.buttons.destroy();
            this.$buttons.parentNode.removeChild(this.$buttons);
        } else {
            if (shouldUpdateDOM && prevOpts.buttons && buttons) {
                this.buttons.clearHtml().render();
            }
        }

        if (!prevOpts.isMobile && isMobile) {
            if (!this.treatAsInline && !$datepickerOverlay) {
                this._createMobileOverlay();


            }
            this._addMobileAttributes();
            if (this.visible) {
                this._showMobileOverlay();
            }
        } else if (prevOpts.isMobile && !isMobile) {
            this._removeMobileAttributes();

            if (this.visible) {
                $datepickerOverlay.classList.remove('-active-');
                if (typeof this.opts.position !== 'function') {
                    this.setPosition();
                }
            }
        }

        if (!shouldUpdateDOM) return;

        this.nav.update();
        this.views[this.currentView].render();
        if (this.currentView === consts.days) {
            this.views[this.currentView].renderDayNames();
        }
    }

    _showMobileOverlay() {
        $datepickerOverlay.classList.add('-active-');
    }

    _hasTransition() {
        let transition = window.getComputedStyle(this.$datepicker).getPropertyValue('transition-duration');
        let props = transition.split(', ');

        return props.reduce((sum, item) => {
            return parseFloat(item) + sum;
        }, 0) > 0;
    }

    //  Utils
    // -------------------------------------------------

    isOtherMonth = (date) => {
        let {month} = getParsedDate(date);

        return month !== this.parsedViewDate.month;
    }

    isOtherYear = (date) => {
        let {year} = getParsedDate(date);

        return year !== this.parsedViewDate.year;
    }

    isOtherDecade = (date) => {
        let {year} = getParsedDate(date);
        let [firstDecadeYear, lastDecadeYear] = getDecade(this.viewDate);

        return year < firstDecadeYear || year > lastDecadeYear;
    }

    //  Subscription events
    // -------------------------------------------------

    _onChangeSelectedDate = ({silent}) => {
        // Use timeout here for wait for all changes that could be made to selected date (e.g. timepicker adds time)
        setTimeout(() => {
            this._setInputValue();
            if (this.opts.onSelect && !silent) {
                this._triggerOnSelect();
            }
        });
    }

    _onChangeFocusedDate = (date, {viewDateTransition} = {}) => {
        if (!date) return;
        let shouldPerformTransition = false;

        if (viewDateTransition) {
            shouldPerformTransition = this.isOtherMonth(date) || this.isOtherYear(date) || this.isOtherDecade(date);
        }

        if (shouldPerformTransition) {
            this.setViewDate(date);
        }

    }

    _onChangeTime = ({hours, minutes}) => {
        let today = new Date();
        let {lastSelectedDate, opts: {onSelect}} = this;
        let targetDate = lastSelectedDate;

        if (!lastSelectedDate) {
            targetDate = today;
        }

        let $cell = this.getCell(targetDate, this.currentViewSingular);
        let cell = !!$cell && !!$cell.adpCell;

        if (cell && cell.isDisabled) return;

        targetDate.setHours(hours);
        targetDate.setMinutes(minutes);

        if (!lastSelectedDate) {
            this.selectDate(targetDate)
        } else {
            this._setInputValue();
            if (onSelect) {
                this._triggerOnSelect();
            }
        }
    }

    _onFocus = (e) => {
        if (!this.visible) {
            this.show();
        }
    }

    _onBlur = (e) => {
        if (!this.inFocus && this.visible && !this.opts.isMobile) {
            this.hide();
        }
    }

    _onMouseDown = (e) => {
        this.inFocus = true;
    }

    _onMouseUp = (e) => {
        this.inFocus = false;
        this.$el.focus();
    }

    _onResize = () => {
        if (this.visible && typeof this.opts.position !== 'function') {
            this.setPosition();
        }
    }

    _onClickOverlay = () => {
        if (this.visible) {
            this.hide();
        }
    }

    isWeekend = (day) => {
        return this.opts.weekends.includes(day);
    }

    /**
     * Clamps passed date between min and max date
     * @param {Date} date
     */
    getClampedDate = (date) => {
        let {minDate, maxDate} = this, newDate = date;

        if (maxDate && isDateBigger(date, maxDate)) {
            newDate = maxDate;
        } else if (minDate && isDateSmaller(date, minDate)) {
            newDate = minDate;
        }

        return newDate;
    }

    on = (eventName, handler) => {
        if (!this.__events) {
            this.__events = {};
        }

        if (!this.__events[eventName]) {
            this.__events[eventName] = [handler];
        } else {
            this.__events[eventName].push(handler);
        }
    };

    off = (eventName, handler) => {
        if (!this.__events) return;
        if (!this.__events[eventName]) return;

        this.__events[eventName] = this.__events[eventName].filter(h => h !== handler);
    };

    removeAllEvents = () => {
        this.__events = {};
    };

    trigger = (eventName, ...args) => {
        if (!this.__events) return;
        if (!this.__events[eventName]) return;

        this.__events[eventName].forEach((handler) => {
            handler(...args);
        });
    }
}

/* Es una clase que muestra una vista semanal de un calendario. */
class WeeklyViewV2 {
    /// Nodes
    $el = document.createElement('div');
    $header = document.createElement('header');
    $headerPrevArrow = document.createElement('span');
    $headerDisplay = document.createElement('span');
    $headerNextArrow = document.createElement('span');
    $body = document.createElement('div');
    $list = document.createElement('ul');

    /// Nodes or Undefined
    $reminder;
    $reminderContent;

    /// Numbers
    listSize = 6;

    /// Arrays
    items = [];
    reminders = [];

    /**
     * *|CURSOR_MARCADOR|*
     * @param [options] - Un objeto que contiene las siguientes propiedades:
     */
    constructor(options = {}) {
        const {
            items = [],
            reminders = [],
            listSize = 6,
            prevWeek = (event = {}) => undefined,
            nextWeek = (event = {}) => undefined,
            onClickCell = (event = {}, cellData = {}) => undefined,
        } = options;

        if (listSize) this.listSize = listSize;

        if (reminders && !!reminders.length) this.reminders = reminders;

        if (items.length - 1 !== this.listSize) throw new Error('El arreglo de items debe ser de 7 elementos');
        if (!this.validateDateList(items)) throw new Error('Los elementos en el arreglo de items deben tener la propiedad "date" y debe ser de tipo <Date>');
        if (typeof onClickCell !== 'function') throw new Error('En las opciones la propiedad "onClickCell" debe ser de tipo <Function(Event = HTMLTargetEvent, CellData = {})>');

        this.items = items;
        this.onClickCell = onClickCell;

        if (typeof prevWeek !== 'function') throw new Error('La propiedad "prevWeek" debes ser de tipo <Function>');
        this.prevWeek = prevWeek;

        if (typeof nextWeek !== 'function') throw new Error('La propiedad "nextWeek" debes ser de tipo <Function>');
        this.nextWeek = nextWeek;

        this.init();
    }

    /// External Methods
    onClickCell = (event = {}, cellData = {}) => undefined;

    /**
     * Toma una matriz de fechas y devuelve verdadero si cada elemento de la matriz es una fecha
     * @param [dateList] - Una serie de fechas.
     * @returns Un valor booleano.
     */
    validateDateList = (dateList = []) => dateList.map(item => item.date instanceof Date).every(item => !!item);

    /**
     * Actualiza el lienzo.
     */
    render = () => {
        this.update();
    }

    /**
     * Esta función elimina todo el HTML del elemento al que está adjunta la vista.
     */
    destroy = (eraseAll = false) => {
        this.$headerPrevArrow.removeEventListener('click', () => undefined);
        this.$headerNextArrow.removeEventListener('click', () => undefined);

        if (eraseAll) {
            const listItems = Array.prototype.slice.call(this.$list.childNodes);

            this.$el.removeChild(this.$header);
            this.$header.removeChild(this.$headerPrevArrow);
            this.$header.removeChild(this.$headerDisplay);
            this.$header.removeChild(this.$headerNextArrow);
            this.$body.removeChild(this.$list);
            this.$el.removeChild(this.$body);
            listItems.forEach(listItem => this.$list.removeChild(listItem));
        }

        this.$el.innerHTML = '';
        this.$header.innerHTML = '';
        this.$header.innerHTML = '';
        this.$header.innerHTML = '';
        this.$body.innerHTML = '';

        this.$el.class = '';
        this.$header.class = '';
        this.$header.class = '';
        this.$header.class = '';
        this.$body.class = '';
    }

    /**
     * La función init se llama cuando se crea el componente. Llama a la función de actualización.
     */
    init = () => {
        this.update();
    }

    /**
     * Actualiza el calendario con las nuevas fechas.
     * @param [items] - Matriz de fechas que se mostrarán en el calendario.
     * @param eraseAll
     */
    update = (items = this.items, eraseAll = false) => {
        if (!this.validateDateList(items)) throw new Error('Los elementos en el arreglo de items deben tener la propiedad "date" y debe ser de tipo <Date>');

        const _items = items.map((item, dayIndex) => ({...item, dayIndex}));

        this.items = _items;

        this.destroy(eraseAll);

        const startDate = _items[0];
        const endDate = _items[_items.length - 1];

        this.buildContent(startDate, endDate);
        _items.forEach(this.buildCell);
    }

    /**
     * Crea el contenido del calendario.
     * @param [startDate] - Fecha de inicio
     * @param [endDate] - Fecha de final
     */
    buildContent = (startDate = {}, endDate = {}) => {
        const _startDate = startDate.date.getUTCDate();

        const _endDate = endDate.date.getUTCDate();
        const _endMonth = endDate.date.getUTCMonth();

        const title = `Semana del ${_startDate} al ${_endDate} de ${getMonthName(_endMonth)}`;

        this.$el.classList.add(`${consts.nameSpace}`,'d-grid');
        this.$header.classList.add(`${consts.nameSpace}-header` , 'd-grid', 't-align-center');
        this.$headerPrevArrow.classList.add(`${consts.nameSpace}-prev`, 'icons', 'chevron-left-block-before', 'c-black', 'icons-2xl', 'cursor-pointer');
        this.$headerDisplay.classList.add(`${consts.nameSpace}-display`, 'typography-h2');
        this.$headerNextArrow.classList.add(`${consts.nameSpace}-next`, 'icons', 'chevron-right-block-before', 'c-black', 'icons-2xl', 'cursor-pointer');
        this.$body.classList.add(`${consts.nameSpace}-body`);
        this.$list.classList.add('week-view-parent-item', 'd-grid', 'p-relative', 'overflow-hidden');

        this.$headerDisplay.textContent = title;

        this.$el.appendChild(this.$header);
        this.$header.appendChild(this.$headerPrevArrow);
        this.$header.appendChild(this.$headerDisplay);
        this.$header.appendChild(this.$headerNextArrow);
        this.$body.appendChild(this.$list);
        this.$el.appendChild(this.$body);

        this.$headerPrevArrow.addEventListener('click', this.prevWeek);
        this.$headerNextArrow.addEventListener('click', this.nextWeek);
    };

    /**
     * La función toma una fecha como argumento y devuelve un elemento de celda con el día, la fecha, el mes y un
     * recordatorio si lo hay.
     * @returns Una celda con un día, fecha, mes y recordatorio.
     * @param cellData
     */
    buildCell = (cellData = {}) => {
        const {date = new Date(), isToday = false, isSelected = false, enable = true, dayIndex = 0} = cellData;

        const prevItem = this.items[!!dayIndex ? dayIndex - 1 : 0];
        const nextItem = this.items[!!dayIndex ? dayIndex + 1 : 0];

        const $cell = document.createElement('li');
        const $cellContent = document.createElement('div');
        const $cellDay = document.createElement('div');
        const $cellDivider = document.createElement('div');
        const $cellDate = document.createElement('div');
        const $cellMonth = document.createElement('div');
        const _day = date.getUTCDay();
        const _date = date.getUTCDate();
        const _year = date.getUTCFullYear();
        const dayName = getDayName(dayIndex, true);
        const dateName = _date.toString();

        const _month = date.getUTCMonth();

        const monthName = getMonthName(_month, true);

        const reminder = this.reminders.find(_reminder => {
            let isReminder = false;

            if (_reminder.date) {
                const _reminderDate = new Date(_reminder.year, _reminder.month - 1, _reminder.date);

                const _reminderUTCDay = _reminderDate.getUTCDay();
                const _reminderUTCDate = _reminderDate.getUTCDate();
                const _reminderUTCMonth = _reminderDate.getUTCMonth();
                const _reminderUTCYear = _reminderDate.getUTCFullYear();

                if (
                    _day === _reminderUTCDay &&
                    _date === _reminderUTCDate &&
                    _month === _reminderUTCMonth &&
                    _year && _reminderUTCYear
                ) isReminder = true;
            }

            return isReminder;
        });

        $cell.classList.add('d-inline-block', 't-align-center');

        if (enable) {
            if (isToday) $cell.classList.add(`${consts.nameSpace}-today`);
            if (isSelected) $cell.classList.add(`${consts.nameSpace}-selected`);
        } else $cell.classList.add(`${consts.nameSpace}-disabled`);

        $cellContent.classList.add(`${consts.nameSpace}-cell` ,'cursor-pointer', 'overflow-hidden', 't-align-center', 'd-grid');
        $cellDay.classList.add(`${consts.nameSpace}-day`, 'c-neutral-extrahigh');
        $cellDivider.classList.add('d-flex', 'j-content-center', 'a-items-center', 'f-column');
        $cellDate.classList.add(`${consts.nameSpace}-date`, 'typography-h2', 'c-neutral-extrahigh');
        $cellMonth.classList.add(`${consts.nameSpace}-month`, 'typography-p', 'c-neutral-high');

        $cellDay.textContent = dayName;
        $cellDate.textContent = dateName;
        $cellMonth.textContent = monthName;

        $cellDivider.appendChild($cellDate);
        $cellDivider.appendChild($cellMonth);

        $cell.appendChild($cellContent);
        $cellContent.appendChild($cellDay);
        $cellContent.appendChild($cellDivider);

        if (!!reminder) {
            this.$reminder = document.createElement('div');
            this.$reminderContent = document.createElement('span');

            this.$reminder.classList.add(`${consts.nameSpace}-reminder`, 'datepicker-reminder-week', 'cursor-pointer', 'p-relative');

            if (!!reminder) {
                const hasWeeklyIconClass = !!reminder.weeklyIconClass && !!reminder.weeklyIconClass.length && !!(reminder.weeklyIconClass || '').split(' ').length;
                const hasColorClass = !!reminder.colorClass && !!reminder.colorClass.length && !!(reminder.colorClass || '').split(' ').length;

                if (hasWeeklyIconClass) this.$reminderContent.classList.add(...reminder.weeklyIconClass.split(' '));
                else {
                    this.$reminderContent.classList.add('icons', 'dot-filled-before', 'icons-xxs');
                    if (hasColorClass) this.$reminderContent.classList.add(reminder.colorClass.split(' '));
                }
            }

            this.$reminder.appendChild(this.$reminderContent);

            $cellContent.appendChild(this.$reminder);
        }

        if (enable) $cell.addEventListener('click', (event) => this.onClickCell(event, cellData));
        this.$list.appendChild($cell);
    }
}



